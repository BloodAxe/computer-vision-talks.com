<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ghostwriter example</title>
    <link>https://example.com/index.xml</link>
    <description>Recent content on Ghostwriter example</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>My Name</copyright>
    <lastBuildDate>Sat, 10 Oct 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Marshalling data in Nodejs C&#43;&#43; modules</title>
      <link>https://example.com/marshalling-data-in-nodejs-c-modules/</link>
      <pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/marshalling-data-in-nodejs-c-modules/</guid>
      <description>

&lt;p&gt;One of the problems I had to solve while working on &lt;a href=&#34;cloudcv&#34;&gt;CloudCV&lt;/a&gt; is a data marshalling from V8 engine to plain C++ objects and vice versa.
In C++ add-on for Nodejs you need to parse and convert input arguments, which can be scalar types, collections and user-defined structures.
Proposed library solves this task with least possible amount of headache.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;example&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;NAN_METHOD(GetFirstNPrimes) {
    
    int numberOfPrimes = Nan::Marshal&amp;lt;int&amp;gt;(info[0]);
    std::vector&amp;lt;int&amp;gt; primes = computeNPrimes(numberOfPrimes);
    info.GetReturnValue().Set(Nan::Marshal(primes));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, enough words, gimme the code! All source code is available on GitHub: &lt;a href=&#34;nan-marshal&#34;&gt;nan-marshal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/more&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;requirements&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;

&lt;p&gt;By tradition, native add-ons for Node are built with GYP build system. So you should install node-gyp package: &lt;code&gt;npm install -g node-gyp&lt;/code&gt;.
This module requires [Nan][nan] package. If you are not using [Nan][nan] already for writing C++ add-ons for Nodejs I strongly advise you to start doing that. Anyway, &lt;code&gt;npm install --save nan&lt;/code&gt; is a right way to start.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;usage&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;Simply add &lt;strong&gt;nan-marshal&lt;/strong&gt; as a dependency module to &lt;em&gt;package.json&lt;/em&gt; of your Node add-on:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npm install --save nan-marshal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add include directories for &lt;strong&gt;NAN&lt;/strong&gt; and &lt;strong&gt;NAN-Marshal&lt;/strong&gt; in your &lt;em&gt;binding.gyp&lt;/em&gt; so that you can use &lt;code&gt;#include &amp;lt;nan-marshal.h&amp;gt;&lt;/code&gt; in your &lt;em&gt;.cpp&lt;/em&gt; files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;include_dirs&amp;quot; : [
    &amp;quot;&amp;lt;!(node -e \&amp;quot;require(&#39;nan&#39;)\&amp;quot;)&amp;quot;,
    &amp;quot;&amp;lt;!(node -e \&amp;quot;require(&#39;nan-marshal&#39;)\&amp;quot;)&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works like a &lt;code&gt;-I&amp;lt;path-to-nan-marshal&amp;gt;&lt;/code&gt; when compiling your add-on.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;api&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;

&lt;p&gt;There is a single all-purpose function: &lt;code&gt;Nan::Marshal&lt;/code&gt;. To convert from V8 object to C++ type, use it as follows: &lt;code&gt;Nan::Marshal&amp;lt;Dst&amp;gt;(V8 object)&lt;/code&gt;.
To convert from C++ to V8 object: &lt;code&gt;Nan::Marshal(..)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Nan::Marshal&lt;/code&gt; supports following types out of the box:
- Built-in C++ types
- std::string
- std::vector
- std::map
- std::shared_ptr
- Marshalling of used-defined types (There are intrusive and non-intrusive options available)&lt;/p&gt;

&lt;p&gt;For built-in and STL types, use is straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Local&amp;lt;Value&amp;gt; arg1 = info[0];
// Marshal from V8 to C++ type
std::string msg = Nan::Marshal&amp;lt;std::string&amp;gt;(arg1);

// Marshal from C++ to V8
info.GetReturnValue().Set(Nan::Marshal(msg));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;User-defined serialization inspired by boost::serialization approach and you will find it similar and easy-to-use. Here&amp;rsquo;s quick example of non-intrusive serialization of the OpenCV data type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace Nan
{
    namespace marshal
    {
        template&amp;lt;typename T&amp;gt;
        struct Serializer &amp;lt; cv::Rect_&amp;lt;T&amp;gt; &amp;gt;
        {
            template&amp;lt;typename InputArchive&amp;gt;
            static inline void load(InputArchive&amp;amp; ar, cv::Rect_&amp;lt;T&amp;gt;&amp;amp; val)
            {
                ar &amp;amp; make_nvp(&amp;quot;x&amp;quot;, val.x);
                ar &amp;amp; make_nvp(&amp;quot;y&amp;quot;, val.y);
                ar &amp;amp; make_nvp(&amp;quot;width&amp;quot;, val.width);
                ar &amp;amp; make_nvp(&amp;quot;height&amp;quot;, val.height);
            }

            template&amp;lt;typename OutputArchive&amp;gt;
            static inline void save(OutputArchive&amp;amp; ar, const cv::Rect_&amp;lt;T&amp;gt;&amp;amp; val)
            {
                ar &amp;amp; make_nvp(&amp;quot;x&amp;quot;, val.x);
                ar &amp;amp; make_nvp(&amp;quot;y&amp;quot;, val.y);
                ar &amp;amp; make_nvp(&amp;quot;width&amp;quot;, val.width);
                ar &amp;amp; make_nvp(&amp;quot;height&amp;quot;, val.height);
            }
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having a snippet above in your code lets you to return JavaScript object like &lt;code&gt;{ x:12, y:13, width:124, height: 144 }&lt;/code&gt; from C++ code. The same is true for V8 -&amp;gt; C++ marshalling. Nan::Marshal will convert V8 object to desired object type.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;tests&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tests&#34;&gt;Tests&lt;/h2&gt;

&lt;p&gt;To run the tests do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install
npm run-script rebuild-tests
npm test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or just:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install
npm test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;limitations&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;limitations&#34;&gt;Limitations&lt;/h2&gt;

&lt;p&gt;This library does not perform strict checking of V8 types during conversion. There is &lt;a href=&#34;https://github.com/BloodAxe/nan-check&#34;&gt;nan-check&lt;/a&gt; module that serves this purpose.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to write a good code</title>
      <link>https://example.com/how-to-write-good-code/</link>
      <pubDate>Wed, 09 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/how-to-write-good-code/</guid>
      <description>

&lt;div class=&#34;featured-image&#34;&gt;
![](featured-image.jpg)
&lt;/div&gt;

&lt;p&gt;This article is a quintessence of my all experience
I&amp;rsquo;ve got for last years working as a computer vision consultant.
I hope you will find this interesting and useful.
My goal was to create set of rules I follow personally on daily basis.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-prefer-functional-approach&#34;&gt;1. Prefer functional approach&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;fp.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Image processing is a place where functional paradigm shows it&amp;rsquo;s bests.
In most cases, image processing algorithm depends only on input image and has no side effects.
This fits perfectly to a &amp;lsquo;pure function&amp;rsquo; term. When possible try to follow this checklist when you define a function in your code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mark all input data with &lt;code&gt;const&lt;/code&gt; modifier to specify immutable arguments.&lt;/li&gt;
&lt;li&gt;Prefer return by reference for large objects (especially for images) instead returning by value.&lt;/li&gt;
&lt;li&gt;In case of class methods, mark methods that does not change class internal state with  &lt;code&gt;const&lt;/code&gt; modifier.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These simple advice helps to understand what and when can you function change. You may remember tricky details of your code today, but who guarantees you&amp;rsquo;ll easily remember that in a month?&lt;/p&gt;

&lt;p&gt;For instance, I want to write implementation of template matching. One may write it as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class TemplateMatchingAlgorithm
{
public:
  TemplateMatchingAlgorithm(cv::Mat templateImage, int method);

  cv::Point matchTemplate(cv::Mat queryImage) const;

private:
  cv::Mat _templateImage;
  int   _method;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compare it with function declaration that does the same job, but looks much cleaner:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void MatchTemplate(cv::Mat templateImage, cv::Mat queryImage, cv::Point&amp;amp; minPoint, int method);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you may ask, should I create class with const method or declare an ordinary function instead?
The short answer - functions are better. I personally use simple decision algorithm:&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
  If the algorithm needs to preserve state between calls - use class; otherwise - use function.
&lt;/div&gt;

&lt;h2 id=&#34;2-don-t-use-virtual-methods&#34;&gt;2. Don&amp;rsquo;t use virtual methods&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;virtualmethods.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You may argue - with classes we can define various implementations for &lt;code&gt;TemplateMatching&lt;/code&gt; using SIDM, CUDA or use template matching in Fourier domain.
Yes, we can. But the price we pay for each call of virtual method is too big for such small routine as template matching.
Usually we use TemplateMatching on small patches like 11x11 pixels to track translation between two frames of video. Hence to achieve robust tracking, number of patches can be quite high - 500 and even 1000 per one frame. Further, coarse-to-fine matching and sub-pixel optimization can lead to ten or more calls for the same feature. In this case, virtual call is a big no-no that will kill your application&amp;rsquo;s performance.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
As a rule of thumb: you *may* use virtual methods to execute big amount of work. Let&#39;s say one virtual call per frame looks totally fine. A thousand calls per frame is obviously a bad, bad idea.
&lt;/div&gt;

&lt;h2 id=&#34;3-write-regression-tests&#34;&gt;3. Write regression tests&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;regression.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Regression testing is a great tool to track all changes in your algorithm and measure it&amp;rsquo;s
precision and performance. Here&amp;rsquo;s an idea:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a ground-truth input dataset&lt;/li&gt;
&lt;li&gt;Process it with your algorithm.&lt;/li&gt;
&lt;li&gt;Save output data and track it in your version control system.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Each time you make changes in implementation - run regression on same input data and compare results.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Regression testing can easily spot numeric stability problems on different compilers / platforms, introduced bugs, platform-dependent optimizations. It&amp;rsquo;s a good idea to include it as a part of regular unit testing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/*
BOOST_AUTO_TEST_CASE(MyAlgorithm, createRegressionDatabaset)
{
    ...
}
/**/

BOOST_AUTO_TEST_CASE(MyAlgorithm, checkRegression)
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I intentionally commented out first test case - in ideal world it should be executed only once.
But sometimes it&amp;rsquo;s necessary to update ground-truth (you fixed a bug in original implementation).
So you uncomment it, run tests, comment it back and check-in new ground-truth.&lt;/p&gt;

&lt;p&gt;You may use any format you like for dumping ground truth data (usually it&amp;rsquo;s some matrices, vectors or images).
Personally, I prefer YAML and JSON.
Just ensure when dumping floating-point numbers to specify maximum output precision.
Otherwise you will have funny weekend debugging absolutely correct algorithm with failing assertion check &lt;code&gt;
0.1543642342365 != 0.154364&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
Once written, regression tests should be run on regular basis either manually or using automated CI system of your choice. 
&lt;/div&gt;

&lt;h2 id=&#34;4-add-logging-to-your-code&#34;&gt;4. Add logging to your code&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;logging.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the simplest case, it could be trivial console logging.
In debug mode you will have all messages in stdout, but in release it will be totally excluded from compilation step.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#if _DEBUG
#define LOG_MESSAGE(x) std::cout &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; &amp;quot; (&amp;quot; &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt; &amp;quot;): &amp;quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
#else
#define LOG_MESSAGE(x)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For complex systems I suggest to use mature logging frameworks like Boost::Log or similar.
They has separation of logging streams (info, trace, warning, errors) and deal with multi-threaded logging.
Logging to file is also useful feature when you want to store program output for further analysis.&lt;/p&gt;

&lt;p&gt;In one of my previous projects, there was a standalone program for logs analysis and data visualization. We logged
all - matrices, vectors regular messages with timestamps. After program finishes we were able to trace program flow
frame by frame and analyze how our algorithms behaved. I cannot count how much hours this tool saved to us on data analysis.&lt;/p&gt;

&lt;p&gt;Logging also helps to spot nasty bugs when you have inconsistent behavior on different platforms. For instance, not so recently I faced a problem when optical flow tracker gave different results on iOS and OSX platforms. After logging all input/output and intermediate data including vectors, matrices I found the root of the evil. It was &lt;code&gt;std::log&lt;/code&gt; function.&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
On OSX ``std::log(float)`` implicitly computes logarithm with double precision and returns truncated result (float). On iOS it computes logarithm using single precision leading to small difference in result. Like a butterfly effect, it affects all other parts of the algorithm. 
&lt;br&gt;
**Without logging it would be practically impossible to spot bug like this**.
&lt;/div&gt;

&lt;h2 id=&#34;5-profile-your-code&#34;&gt;5. Profile your code&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;profilerdump.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Algorithm performance usually a top-level priority since this kind of applications deal with real-time video processing and processing of huge amount of data.
Therefore it&amp;rsquo;s crucial to know how fast your algorithms runs or do they become slower or faster with refactoring you perform.
There are plenty of ways to collect this data.&lt;/p&gt;

&lt;h3 id=&#34;xcode-instruments&#34;&gt;XCode Instruments&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;re targeting on OSX and iOS platform, Apple Xcode and Instruments can be your first choice due to natural integration of profiling tools to IDE.
Instruments can be handy to spot problematic places in your code. But Instruments uses sampling technique, which is not precise.&lt;/p&gt;

&lt;h3 id=&#34;vtune-visualstudio&#34;&gt;VTune/VisualStudio&lt;/h3&gt;

&lt;p&gt;For Windows users Visual Studio offers integrated profiler as well.
Unlike Instruments, it can do instrumentation of your binary.
It means each function in your program modified with special prolog and epilog code that measure execution time of all your program.
Instrumenting provides you a lot of information per each routine: calls count, execution time, inclusive / exclusive CPU time, call tread and CPU cores load.
This is much more you have with Apple Instruments.&lt;/p&gt;

&lt;h3 id=&#34;cv-gettickcount&#34;&gt;cv::getTickCount&lt;/h3&gt;

&lt;p&gt;Sometimes you don&amp;rsquo;t want to profile entire application. Instead you want to &amp;lsquo;cherry-pick&amp;rsquo; only a single function and profile it. For this purpose you can use monotonic clock and measure execution time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define MEASURE_TIME(x)                        \
        { auto startTime = cv::getTickCount(); \ 
          x;                                   \
          auto endTime = cv::getTickCount();   \
          std::cout &amp;lt;&amp;lt; #x &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; (endTime - startTime) * cv::getTickFrequency() &amp;lt;&amp;lt; std::endl; }

// Measure MatchTemplate
MEASURE_TIME(MatchTemplate(a,b,result));
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
  Profile your code. Always.
&lt;/div&gt;

&lt;h2 id=&#34;6-optimize-code&#34;&gt;6. Optimize code&lt;/h2&gt;

&lt;h3 id=&#34;6-1-loop-vectorization&#34;&gt;6.1 Loop vectorization&lt;/h3&gt;

&lt;p&gt;Compilers can do loops vectorization when data flow and iterations count are clear enough.
This heuristic analysis depends on implementation, so CLang has different vectorization analysis engine than MSVC. But you can give your compiler a hint:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SSD(cv::Mat i1, cv::Mat i2)
{
  int i = 0;
  const uint8_t * a = templateImage.data;
  const uint8_t * b = templateImage.data;
  
  int ssd = 0;

  for (; i &amp;lt; (length/4)*4; i+=4)
  {
    ssd += SQR(a[i+0] - b[i+0]);
    ssd += SQR(a[i+1] - b[i+1]);
    ssd += SQR(a[i+2] - b[i+2]);
    ssd += SQR(a[i+3] - b[i+3]);
  }

  for (; i &amp;lt; length; i++, a++, b++)
  {
    ssd += SQR(a[i] - b[i]);
  }

  return ssd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This partial loop unrolling gives enough information to compiler.
As a result it can replace partially unrolled summation with SIMD instruction.&lt;/p&gt;

&lt;h3 id=&#34;6-2-bring-constants-at-compile-time&#34;&gt;6.2 Bring constants at compile time&lt;/h3&gt;

&lt;p&gt;If you have a priory knowledge on size of data you pass to particular function, it may make sense to write function that
employs this information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename TOut, typename TIn, int RowsAtCompileTime, int ColsAtCompileTime&amp;gt;
inline TOut SSD(const cv::Matx_&amp;lt;TIn, RowsAtCompileTime, ColsAtCompileTime&amp;gt;&amp;amp; a, 
                const cv::Matx_&amp;lt;TIn, RowsAtCompileTime, ColsAtCompileTime&amp;gt;&amp;amp; b) nothrow
{
  int i = 0;
  const TIn * a = templateImage.data;
  const TIn * b = templateImage.data;
  
  TOut ssd = 0;

  for (int i = 0; i &amp;lt; RowsAtCompileTime * ColsAtCompileTime; i++, a++, b++)
  {
    ssd += (TOut)SQR(a[i] - b[i]);
  }

  return ssd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since compiler knows size of the array to process, it can easily generate vectorized code for this routine.
The drawback of this approach is slightly increased code size if you instantiate this template function with many sizes.
But you get better performance which usually worth it.&lt;/p&gt;

&lt;h3 id=&#34;6-3-architecture-dependent-implementations&#34;&gt;6.3 Architecture-dependent implementations&lt;/h3&gt;

&lt;p&gt;Architecture-specific features like SIMD instructions can make your code runs much, much faster than generic C++
implementation.
It is a must-have feature on mobile platforms since it makes your code faster and at the same time it
conservate battery power of host device.
There are more and more devices with CUDA and OpenCL support.
And the question is - how do I manage all those possible architecture / platforms combinations of optimized functions in my code?&lt;/p&gt;

&lt;p&gt;Here it&amp;rsquo;s how I solved this task for myself:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace mypublicnamespace
{
    void MatchTemplate(cv::Mat templateImage, cv::Mat queryImage, cv::Point&amp;amp; minPoint, int method)
    {
#if TARGET_PLATFORM_HAS_NEON_SIMD
        details::neon::MatchTemplate(templateImage, queryImage, minPoint, method);
#elif TARGET_PLATFORM_HAS_SSE_SIMD
        details::sse::MatchTemplate(templateImage, queryImage, minPoint, method);
#elif TARGET_PLATFORM_HAS_OPENCL
        details::opencl::MatchTemplate(templateImage, queryImage, minPoint, method);
#else        
        details::generic::MatchTemplate(templateImage, queryImage, minPoint, method);
#endif    
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code snippet demonstrate compile-time dispatching for particular implementation of a function declared in &lt;code&gt;mypublicnamespace&lt;/code&gt;. Of course, you should take care of preprocessor defines that declare platform / architecture capabilities. I&lt;/p&gt;

&lt;h3 id=&#34;6-4-branch-prediction&#34;&gt;6.4 Branch prediction&lt;/h3&gt;

&lt;p&gt;Suppose you have a-priory knowledge that condition expression will be almost always true.
Why don&amp;rsquo;t give this intrinsic knowledge to compiler? By supplying &lt;em&gt;expected&lt;/em&gt; condition result compiler can
generate more efficient code. As a result, CPU will start decoding instructions earlier.&lt;/p&gt;

&lt;p&gt;Unfortunately, this feature supported only on GCC and CLANG.
But according to measurements, it can provide significant speed-up up to ~15%. You can find more information here: &lt;a href=&#34;http://blog.man7.org/2012/10/how-much-do-builtinexpect-likely-and.html&#34;&gt;How much do __builtin_expect(), likely(), and unlikely() improve performance?&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define LIKELY(x)      __builtin_expect(!!(x), 1)
#define UNLIKELY(x)    __builtin_expect(!!(x), 0)

if (LIKELY(x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt;= image_width))
{
  // Compute something
}

if (UNLIKELY(std::fabs(value) &amp;lt;= std::numeric_limits&amp;lt;float&amp;gt;::epsilon()))
{
  throw std::runtime_error(&amp;quot;Value is zero&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-5-openmp&#34;&gt;6.5 OpenMP&lt;/h3&gt;

&lt;p&gt;Starting from OpenMP 4.0, you can instruct compiler to generate vectorized code by adding new pragma instructions to your loops:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void MatchTemplate(cv::Mat templateImage, cv::Mat queryImage, cv::Point&amp;amp; minPoint, int method)
{
  uint8_t * a = templateImage.data;
  uint8_t * b = templateImage.data;
  
  int ssd = 0;

#pragma omp simd reduction(+:x)
  for (int i = 0; i &amp;lt; length; i++)
  {
    ssd += SQR(a[0] - b[0]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With only single &lt;code&gt;#pragma&lt;/code&gt; instruction you made your code runs faster.
I encourage you to visit &lt;a href=&#34;https://software.intel.com/en-us/articles/enabling-simd-in-program-using-openmp40&#34;&gt;Enabling SIMD in program using OpenMP4.0&lt;/a&gt; webpage for more information of supported OpenMP SIMD instructions.&lt;/p&gt;

&lt;h3 id=&#34;7-use-imageview&#34;&gt;7. Use ImageView&lt;/h3&gt;

&lt;p&gt;For Windows users there is a great Visual Studio plugin called &lt;a href=&#34;https://visualstudiogallery.msdn.microsoft.com/e682d542-7ef3-402c-b857-bbfba714f78d&#34;&gt;ImageWatch&lt;/a&gt; that makes our life so simple.
This plugin can visualize OpenCV matrices right in IDE.
It is hard to overestimate the usefulness of this plugin.
You can see how images are changing while debugging.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image_watch.png&#34; alt=&#34;Image watch&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Next time when you start development of new algorithm, keep in mind these simple steps.
They will help you create fast, maintainable and clear code. Here they are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Prefer functional approach&lt;/li&gt;
&lt;li&gt;Try avoid virtual calls&lt;/li&gt;
&lt;li&gt;Write vectorization-friendly code&lt;/li&gt;
&lt;li&gt;Use all available debugging / profiling tools&lt;/li&gt;
&lt;li&gt;Measure your code performance&lt;/li&gt;
&lt;li&gt;Write tests and check regression&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hope you found this post useful. Discussion is more than welcome. Please share your thoughts in comments.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing CloudCV bootstrap</title>
      <link>https://example.com/introducing-cloudcv-bootstrap/</link>
      <pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/introducing-cloudcv-bootstrap/</guid>
      <description>

&lt;p&gt;Here&amp;rsquo;s an open-source ready to use bootstrap project written in Node.js that lets
you to quickly build a REST service to host your image processing and computer vision code
in a cloud environment.
Please welcome: &lt;a href=&#34;https://github.com/CloudCV/cloudcv-bootstrap&#34;&gt;cloudcv-bootstrap&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;cloudcv-bootstrap.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I made this project aside of CloudCV to keep it simple but functionaly. It is self-contained
Node.js project that helps you to get quick results on building and deploying your first
server-based image processing service.&lt;/p&gt;

&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ready to use. No need to download extra dependencies. Just run &lt;code&gt;npm install&lt;/code&gt; and that&amp;rsquo;s all.&lt;/li&gt;
&lt;li&gt;Built-in REST-API support. As a bonus, a Swagger 2.0 specification file comes too. You can use it as a template to build client SDKs.&lt;/li&gt;
&lt;li&gt;Shipped with OpenCV 3.0.0&lt;/li&gt;
&lt;li&gt;Interopability between C++ and Node.js code&lt;/li&gt;
&lt;li&gt;Covered with unit tests&lt;/li&gt;
&lt;li&gt;Logging support&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With cloudcv-bootstrap you can quickly wrap your C++ code into web-service using simple and
clear syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;app.post(&#39;/api/v1/image/analyze/dominantColors/&#39;, function (req, res) {
    cv.analyzeImage(req.files.image.buffer, function(error, result) {
        res.setHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;);
        res.write(JSON.stringify(MapAnalyzeResult(result)));
        res.end();
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Error handling and logging here omited for the sake of simplicity, but this is full-functional snippet.
It accepts uploaded image using POST request and transfers image data to C++ backend.
&lt;a href=&#34;https://github.com/CloudCV/cloudcv-bootstrap&#34;&gt;cloudcv-bootstrap&lt;/a&gt; fully follows Node.js programming paradigm and schedule C++ code on libuv thread pool and leave main thread free for requests processing.&lt;/p&gt;

&lt;h2 id=&#34;quick-start&#34;&gt;Quick start&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/CloudCV/cloudcv-bootstrap.git
npm install
npm start &amp;amp;
curl localhost:3000/api/v1/image/analyze/dominantColors?image=https%3A%2F%2Fraw.githubusercontent.com%2FCloudCV%2Fcloudcv-bootstrap%2Fmaster%2Ftest%2Fdata%2Fopencv-logo.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Produces:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{
    &amp;quot;aspect&amp;quot;:
    {
        &amp;quot;width&amp;quot;:599,
        &amp;quot;height&amp;quot;:555
    },
    &amp;quot;size&amp;quot;:
    {
        &amp;quot;width&amp;quot;:0,
        &amp;quot;height&amp;quot;:0
    },
    &amp;quot;dominantColors&amp;quot;:
    [
        {&amp;quot;color&amp;quot;:[252,252,252],&amp;quot;totalPixels&amp;quot;:201655,&amp;quot;interclassVariance&amp;quot;:7.83907795204613e-37,&amp;quot;error&amp;quot;:0},
        {&amp;quot;color&amp;quot;:[252,0,0],&amp;quot;totalPixels&amp;quot;:43612,&amp;quot;interclassVariance&amp;quot;:7.83907795204613e-37,&amp;quot;error&amp;quot;:0},
        {&amp;quot;color&amp;quot;:[0,0,252],&amp;quot;totalPixels&amp;quot;:43591,&amp;quot;interclassVariance&amp;quot;:7.83907795204613e-37,&amp;quot;error&amp;quot;:0},
        {&amp;quot;color&amp;quot;:[0,252,0],&amp;quot;totalPixels&amp;quot;:43587,&amp;quot;interclassVariance&amp;quot;:7.83907795204613e-37,&amp;quot;error&amp;quot;:0}
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Congratulations, you&amp;rsquo;ve just computed dominant colors of the OpenCV logo image:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/CloudCV/cloudcv-bootstrap/master/test/data/opencv-logo.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;extending-with-your-code&#34;&gt;Extending with your code&lt;/h2&gt;

&lt;p&gt;This module uses node-gyp build system. It produces Node C++ addon and require you to do minimal changes into this module:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Have C++ code you want to host&lt;/li&gt;
&lt;li&gt;Write module binding&lt;/li&gt;
&lt;li&gt;Register it&lt;/li&gt;
&lt;li&gt;Write unit tests&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s go step by step using camera calibration as example. For quick results we won&amp;rsquo;t reinvent the wheel and use code from OpenCV samples. I will just refactor it slightly. Here&amp;rsquo;s our public interface of calibration algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum PatternType {
    CHESSBOARD = 0,
    CIRCLES_GRID = 1,
    ACIRCLES_GRID = 2
};

class CameraCalibrationAlgorithm
{
public:
    typedef std::vector&amp;lt;cv::Point3f&amp;gt;               VectorOf3DPoints;
    typedef std::vector&amp;lt;cv::Point2f&amp;gt;               VectorOf2DPoints;
    typedef std::vector&amp;lt;std::vector&amp;lt;cv::Point3f&amp;gt; &amp;gt; VectorOfVectorOf3DPoints;
    typedef std::vector&amp;lt;std::vector&amp;lt;cv::Point2f&amp;gt; &amp;gt; VectorOfVectorOf2DPoints;
    typedef std::vector&amp;lt;cv::Mat&amp;gt;                   VectorOfMat;

    CameraCalibrationAlgorithm(cv::Size patternSize, PatternType type);

    bool detectCorners(const cv::Mat&amp;amp; frame, VectorOf2DPoints&amp;amp; corners2d) const;

    bool calibrateCamera(
        const VectorOfVectorOf2DPoints&amp;amp; gridCorners,
        const cv::Size imageSize,
        cv::Mat&amp;amp; cameraMatrix,
        cv::Mat&amp;amp; distCoeffs
    ) const;

protected:

    // .. plenty of helper methods

private:
    cv::Size                 m_patternSize;
    PatternType              m_pattern;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to wrap it into V8 code. First, we need to register corresponding function that we will expose to JS:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void RegisterModule(Handle&amp;lt;Object&amp;gt; target)
{
    // ...

    NODE_SET_METHOD(target, &amp;quot;calibrationPatternDetect&amp;quot;, calibrationPatternDetect);
    NODE_SET_METHOD(target, &amp;quot;calibrateCamera&amp;quot;,          calibrateCamera);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Implementation of &lt;code&gt;calibrationPatternDetect&lt;/code&gt; and &lt;code&gt;calibrateCamera&lt;/code&gt; needs to parse input arguments, schedule a task to thread pool and invoke a user-passed callback on completition.
Marshalling between C++ and V8 is tricky.
Fortunately, NaN module does a great help on data marshalling.
To simplity developer&amp;rsquo;s life even more &lt;a href=&#34;https://github.com/CloudCV/cloudcv-bootstrap&#34;&gt;cloudcv-bootstrap&lt;/a&gt; offers complex data marshalling and argument checking:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;NAN_METHOD(calibrationPatternDetect)
{
    TRACE_FUNCTION;
    NanEscapableScope();

    Local&amp;lt;Object&amp;gt;   imageBuffer;
    Local&amp;lt;Function&amp;gt; callback;
    cv::Size        patternSize;
    PatternType     pattern;
    std::string     error;

    if (NanCheck(args)
        .Error(&amp;amp;error)
        .ArgumentsCount(4)
        .Argument(0).IsBuffer().Bind(imageBuffer)
        .Argument(1).Bind(patternSize)
        .Argument(2).StringEnum&amp;lt;PatternType&amp;gt;({ 
            { &amp;quot;CHESSBOARD&amp;quot;,     PatternType::CHESSBOARD }, 
            { &amp;quot;CIRCLES_GRID&amp;quot;,   PatternType::CIRCLES_GRID }, 
            { &amp;quot;ACIRCLES_GRID&amp;quot;,  PatternType::ACIRCLES_GRID } }).Bind(pattern)
        .Argument(3).IsFunction().Bind(callback))
    {
        LOG_TRACE_MESSAGE(&amp;quot;Parsed function arguments&amp;quot;);
        NanCallback *nanCallback = new NanCallback(callback);
        NanAsyncQueueWorker(new DetectPatternTask(
            CreateImageSource(imageBuffer), 
            patternSize, 
            pattern, 
            nanCallback));
    }
    else if (!error.empty())
    {
        LOG_TRACE_MESSAGE(error);
        NanThrowTypeError(error.c_str());
    }

    NanReturnUndefined();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may read about NanCheck in separate post: &lt;a href=&#34;http://computer-vision-talks.com/articles/how-to-convert-args-from-js-to-cpp&#34;&gt;NanCheck&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;data-marshalling&#34;&gt;Data marshalling&lt;/h2&gt;

&lt;p&gt;Natively, marshaller supports:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C++ plain types&lt;/strong&gt;:
 - char, unsigned char
 - short, unsighed short
 - int, unsigned int
 - long, unsigned long
 - float, double
 - T[N]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;STL types&lt;/strong&gt;:
 - std::array&lt;T,N&gt;
 - std::pair&lt;A,B&gt;
 - std::vector&lt;T&gt;
 - std::map&lt;K,V&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OpenCV types&lt;/strong&gt;:
 - cv::Point2i, cv::Point2f, cv::Point2d
 - cv::Size&lt;em&gt;&lt;int&gt;, cv::Size&lt;/em&gt;&lt;float&gt;, cv::Size_&lt;double&gt;
 - cv::Mat&lt;/p&gt;

&lt;p&gt;Data marshalling of user-defined structures implemented in similar to boost::serialization fashion:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct CalibrationResult
{
    cv::Mat  m_distCoeffs;
    cv::Mat  m_cameraMatrix;
    bool     m_calibrationSuccess;

    template &amp;lt;typename Archive&amp;gt;
    void serialize(Archive&amp;amp; ar)
    {
        ar &amp;amp; serialization::make_nvp(&amp;quot;calibrationSuccess&amp;quot;, m_calibrationSuccess);

        if (Archive::is_loading::value || m_calibrationSuccess)
        {
            ar &amp;amp; serialization::make_nvp(&amp;quot;cameraMatrix&amp;quot;,m_cameraMatrix);
            ar &amp;amp; serialization::make_nvp(&amp;quot;distCoeffs&amp;quot;,  m_distCoeffs);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;User-defined types will be marshalled to regular V8 object containing fields serialized within &lt;code&gt;serialize()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;To marshal C++ object to V8 object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;CalibrationResult cpp_result = ...;
auto v8_result = marshal(cpp_result);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To marshal from V8 object to C++ object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;v8::Local&amp;lt;v8::Value&amp;gt; v8_result = ...;
auto cpp_result = marshal&amp;lt;CalibrationResult&amp;gt;(v8_result);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;roadmap&#34;&gt;Roadmap&lt;/h2&gt;

&lt;p&gt;This is very beta version of cloudcv-bootstrap and it&amp;rsquo;s codebase about to change.
Please keep in mind that and feel free to ask for help in &lt;a href=&#34;https://twitter.com/cvtalks&#34;&gt;twitter&lt;/a&gt; or on &lt;a href=&#34;https://github.com/CloudCV/cloudcv-bootstrap/issues&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;According to plan:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Add Dockerfile to run this code in a container environment&lt;/li&gt;
&lt;li&gt;Write more documentation on data marshalling&lt;/li&gt;
&lt;li&gt;Implement easier REST API mapping and arguments checking&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://example.com/page/about/</link>
      <pubDate>Fri, 03 Apr 2015 02:13:50 +0000</pubDate>
      
      <guid>https://example.com/page/about/</guid>
      <description>

&lt;h2 id=&#34;about&#34;&gt;About&lt;/h2&gt;

&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean nec dolor in magna lobortis egestas. Suspendisse eu erat tempor, tristique neque eu, convallis nulla. Curabitur vel bibendum lacus, at semper mauris. Suspendisse aliquet commodo ex, sed sagittis metus aliquam id. Maecenas feugiat rutrum lorem vel imperdiet. Nullam ornare lectus ut enim finibus, et porttitor mi tincidunt. Aenean lacinia, leo quis vehicula eleifend, quam libero sagittis erat, at euismod augue mauris et sapien. Sed id vehicula lectus, sit amet auctor ipsum. Nunc sed massa vel ex condimentum aliquam in a enim. Cras enim sem, tristique eu enim ac, congue commodo mi. Integer quis orci at dolor blandit eleifend.&lt;/p&gt;

&lt;h2 id=&#34;school&#34;&gt;School&lt;/h2&gt;

&lt;p&gt;Sed quis pulvinar nisi, sed dapibus lacus. Mauris tempus ex ut ipsum facilisis interdum. Integer feugiat urna sed feugiat tempor. Quisque dictum vestibulum feugiat. Nunc nec est volutpat lorem imperdiet egestas sit amet ut orci. Aliquam venenatis neque ipsum, a placerat lectus cursus at. Donec pellentesque tellus hendrerit faucibus posuere. Etiam gravida consequat lectus, volutpat consectetur velit convallis nec. Praesent sagittis luctus dignissim.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>https://example.com/page/contact/</link>
      <pubDate>Fri, 03 Apr 2015 02:13:50 +0000</pubDate>
      
      <guid>https://example.com/page/contact/</guid>
      <description>

&lt;h2 id=&#34;contact&#34;&gt;Contact&lt;/h2&gt;

&lt;p&gt;Aenean ipsum justo, semper eu nisl ut, pretium tincidunt sem. Praesent et diam sit amet lacus lobortis dictum a id lacus. Quisque hendrerit sit amet turpis eu varius. Ut id lorem ac felis ultrices tincidunt. Pellentesque consequat arcu ac fringilla imperdiet. Phasellus pellentesque, sapien non pulvinar blandit, sapien ante aliquet felis, vel porttitor sapien ante in lacus. Fusce non urna aliquet, malesuada nibh vel, luctus urna. Phasellus ut lacus molestie, varius purus quis, malesuada lorem.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to debug node.js addons in Visual Studio</title>
      <link>https://example.com/how-to-debug-nodejs-addons-in-visual-studio/</link>
      <pubDate>Tue, 17 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/how-to-debug-nodejs-addons-in-visual-studio/</guid>
      <description>

&lt;p&gt;While working on &lt;a href=&#34;https://cloudcv.io&#34;&gt;CloudCV&lt;/a&gt; I encountered problems in node.js addon written in native code. For CloudCV I use node.js with C++ Addon to separate high-performance algorithms (C++) from high-level networking API which node provides.&lt;/p&gt;

&lt;p&gt;In this tutorial I&amp;rsquo;m going to reveal best practices on debugging C++ Addons for Node.js (0.12) using Visual Studio 2013.&lt;/p&gt;

&lt;div class=&#34;embed-responsive embed-responsive-4by3&#34;&gt;
  &lt;iframe class=&#34;embed-responsive-item&#34; src=&#34;https://www.youtube.com/embed/eqhv42jVN6s&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Continue reading if you want to read in details why this works.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This article is valid for Node.js version 0.12. It should also works fine for further releases, however few things may change. I will try to keep this post up to date. Please, feel free to drop a comment for this article or write me on &lt;a href=&#34;https://twitter.com/cvtalks&#34;&gt;@cvtalks&lt;/a&gt; if you have troubles following this tutorial.&lt;/p&gt;

&lt;h2 id=&#34;before-we-start&#34;&gt;Before we start&lt;/h2&gt;

&lt;p&gt;You will need a Visual Studio 2013 (&lt;a href=&#34;http://go.microsoft.com/?linkid=9832256&#34;&gt;Express edition&lt;/a&gt; should be enough). Also, please come and grab &lt;a href=&#34;http://nodejs.org/dist/v0.12.0/node-v0.12.0.tar.gz&#34;&gt;Node.js source&lt;/a&gt;] code. We will use it later to build Debug configuration of Node.js. I assume you
already have production (Release) version of Node and NPM as we will need &lt;a href=&#34;https://github.com/TooTallNate/node-gyp&#34;&gt;node-gyp&lt;/a&gt; to generate and build C++ Addon project. So please ensure you&amp;rsquo;ve installed them before going to next step:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install -g node-gyp
npm install -g nan
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-debug-configuration-of-node-js&#34;&gt;Build Debug configuration of node.js&lt;/h2&gt;

&lt;p&gt;This is very straighforward step.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Download &lt;a href=&#34;http://nodejs.org/dist/v0.12.0/node-v0.12.0.tar.gz&#34;&gt;Node.js source&lt;/a&gt;] code.&lt;/li&gt;
&lt;li&gt;Extract it somewhere to your filesystem. For demonstration, I assume it will be in &lt;code&gt;c:\Develop\node-v0.12.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Navigate to &lt;code&gt;c:\Develop\node-v0.12.0&lt;/code&gt; and run &lt;code&gt;vcbuild.bat debug nosign x64&lt;/code&gt;. This batch script will build Debug configuration of node.js for 64-bit architecture (if you&amp;rsquo;re on 32-bit platform omit this flag). A &lt;code&gt;nosign&lt;/code&gt; flag tells to skip executable signing which is ok since we&amp;rsquo;re not going to distribute it, and finally &lt;code&gt;debug&lt;/code&gt; forces compiler to generate debug symbols for node executable.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;build-node-debug-step-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If everything goes fine, you should see the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;c:\Develop\node-v0.12.0&amp;gt;vcbuild.bat debug nosign x64
ctrpp not found in WinSDK path--using pre-gen files from tools/msvs/genfiles.
creating  icu_config.gypi

...

creating  config.gypi
creating  config.mk
Project files generated.

...

debugger-agent.vcxproj -&amp;gt; c:\Develop\node-v0.12.0\Debug\lib\debugger-agent.lib
v8_nosnapshot.vcxproj -&amp;gt; ..\..\..\..\build\Debug\lib\v8_nosnapshot.lib
openssl-cli.vcxproj -&amp;gt; c:\Develop\node-v0.12.0\Debug\\openssl-cli.exe
mksnapshot.vcxproj -&amp;gt; ..\..\..\..\build\Debug\\mksnapshot.exe
v8_snapshot.vcxproj -&amp;gt; ..\..\..\..\build\Debug\lib\v8_snapshot.lib
node.vcxproj -&amp;gt; c:\Develop\node-v0.12.0\Debug\\node.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;build-node-debug-step-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you have problems on this step, please refer to &lt;a href=&#34;https://github.com/joyent/node/wiki/installation#building-on-windows&#34;&gt;building node.js&lt;/a&gt; official documentation.&lt;/p&gt;

&lt;h2 id=&#34;building-debug-configuration-of-c-addon&#34;&gt;Building Debug configuration of C++ Addon&lt;/h2&gt;

&lt;p&gt;A C++ Addon for nodejs is nothing but ordinary DLL. Therefore Visual Studio can load it and let you do step-by-step debugging inside node.js app.
Let&amp;rsquo;s start with simple scenario. I will use &lt;a href=&#34;https://github.com/rvagg/nan/tree/master/examples/async_pi_estimate&#34;&gt;Pi estimation&lt;/a&gt; example from &lt;a href=&#34;https://github.com/rvagg/nan&#34;&gt;NaN&lt;/a&gt; project.&lt;/p&gt;

&lt;p&gt;Your C++ Addon code can look as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/*********************************************************************
 * NAN - Native Abstractions for Node.js
 *
 * Copyright (c) 2015 NAN contributors
 *
 * MIT License &amp;lt;https://github.com/rvagg/nan/blob/master/LICENSE.md&amp;gt;
 ********************************************************************/

var addon = require(&#39;./build/Release/addon&#39;);
var calculations = process.argv[2] || 100000000;

function printResult(type, pi, ms) {
  console.log(type, &#39;method:&#39;)
  console.log(&#39;\tπ ≈ &#39; + pi
        + &#39; (&#39; + Math.abs(pi - Math.PI) + &#39; away from actual)&#39;)
    console.log(&#39;\tTook &#39; + ms + &#39;ms&#39;);
    console.log()
}

function runSync () {
  var start = Date.now();
  // Estimate() will execute in the current thread,
  // the next line won&#39;t return until it is finished
    var result = addon.calculateSync(calculations);
  printResult(&#39;Sync&#39;, result, Date.now() - start)
}

function runAsync () {
  // how many batches should we split the work in to?
    var batches = process.argv[3] || 16;
    var ended = 0;
    var total = 0;
    var start = Date.now();

    function done (err, result) {
        total += result;

    // have all the batches finished executing?
        if (++ended == batches) {
            printResult(&#39;Async&#39;, total / batches, Date.now() - start)
        }
    }

  // for each batch of work, request an async Estimate() for
  // a portion of the total number of calculations
    for (var i = 0; i &amp;lt; batches; i++) {
        addon.calculateAsync(calculations / batches, done);
    }
}

runSync()
runAsync()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you also should have gyp file which tells node-gyp how to build your addon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gyp&#34;&gt;{
  &amp;quot;targets&amp;quot;: [
    {
      &amp;quot;target_name&amp;quot;: &amp;quot;addon&amp;quot;,
      &amp;quot;sources&amp;quot;: [
        &amp;quot;addon.cc&amp;quot;,
        &amp;quot;pi_est.cc&amp;quot;,
        &amp;quot;sync.cc&amp;quot;,
        &amp;quot;async.cc&amp;quot;
      ],
      &amp;quot;include_dirs&amp;quot;: [&amp;quot;&amp;lt;!(node -e \&amp;quot;require(&#39;nan&#39;)\&amp;quot;)&amp;quot;]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming you&amp;rsquo;re in root C++ addon directory, you can now generate a solution for Visual Studio to build your addon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;node-gyp configure rebuild --nodedir=&amp;quot;c:\Develop\node-v0.12.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;build-addon-step-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;What is really important here, is &lt;code&gt;--nodedir=&amp;quot;c:\Develop\node-v0.12.0&amp;quot;&lt;/code&gt; flag, which indicates to link against node in specified
folder rather than system wide available.&lt;/p&gt;

&lt;p class=&#34;bg-info lead&#34;&gt;
This is very important to match Debug node with Debug C++ Addon, otherwise you will have 
linker issues caused by inconsistent CRT&#39;s.
&lt;/p&gt;

&lt;p&gt;After node-gyp finishes, a .node file (this is .dll, don&amp;rsquo;t be misleaded by .node extension) will be generated in /build/Debug/ folder.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;build-addon-step-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to write a small node.js script that utilizes our addon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nodejs&#34;&gt;var addon = require(&#39;./build/Release/addon&#39;);

function printResult(type, pi, ms) {
  console.log(type, &#39;method:&#39;)
  console.log(&#39;\tπ ≈ &#39; + pi
        + &#39; (&#39; + Math.abs(pi - Math.PI) + &#39; away from actual)&#39;)
    console.log(&#39;\tTook &#39; + ms + &#39;ms&#39;);
    console.log()
}

function runAsync () {

    var start = Date.now();

    function done (err, result) {
        console.log(&#39;\tπ ≈ &#39; + pi + &#39; (&#39; + Math.abs(pi - Math.PI) + &#39; away from actual)&#39;)
        console.log(&#39;\tTook &#39; + ms + &#39;ms&#39;);
        console.log()

        printResult(&#39;Async&#39;, total / batches, Date.now() - start)
    }

    addon.calculateAsync(1024, done);
}

runAsync()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may wonder now, how to debug it. Patience, we&amp;rsquo;re almost there.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;generated-project.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Navigate to &lt;code&gt;build/&lt;/code&gt; directory of your C++ Addon and
open solution file.&lt;/li&gt;
&lt;li&gt;Ensure that you have active Debug configuration.&lt;/li&gt;
&lt;li&gt;Navigate to project properties and open Debugging tab there.&lt;/li&gt;
&lt;li&gt;Modify command name to &amp;ldquo;c:\Develop\node-v0.12.0\Node.exe&amp;rdquo; (Change this path if you extracted node somewhere else)&lt;/li&gt;
&lt;li&gt;Set a command argument to full name of your node.js script.&lt;/li&gt;
&lt;li&gt;Change working directory to a place where your script is. This step important when you have complex nodej.js application with
dependencies.&lt;/li&gt;
&lt;li&gt;Set breakpoint somewhere in your C++ Addon code.&lt;/li&gt;
&lt;li&gt;Now hit &amp;lsquo;Debug&amp;rsquo; (F5) and enjoy!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;vsproject-settings.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;

&lt;p&gt;When building Debug builds, Visual Studio trades speed for easy debugging. This means not only slower code, but it also preserves debug
symbols (a table of function addresses/names/file locations). When you start a debugger on process, VS attachs to it and tries to load
symbols for this binary and all dynamically loaded libraries it uses.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;vsproject-debugging.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As a consequence, debug symbols for C++ addon is being loaded which allows you to see program execution location in your IDE,
do step-by-step debugging and change/rebuild/debug as usual.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope you find this post useful. From my experience debugging node.js &amp;lt;-&amp;gt; C++ interop can be nasty. Personally I follow this
scenario for debugging CloudCV C++ backend. This saves a lot of time and nerves. Unleash your node.js with C++ and happy debugging!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hacking OpenCV for fun and profit</title>
      <link>https://example.com/hacking-opencv-for-fun-and-profit/</link>
      <pubDate>Thu, 25 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/hacking-opencv-for-fun-and-profit/</guid>
      <description>

&lt;div class=&#34;featured-image&#34;&gt;
![](logo.png)
&lt;/div&gt;

&lt;p&gt;This post convers very specific but important topic about writing memory-efficient code.
I will show you how to collect and analyze memory allocations that happens in OpenCV.&lt;/p&gt;

&lt;p&gt;When it comes to writing efficient code we usually care about CPU-efficiency. However there are
many times, when memory-efficiency is more important. A limited amount of RAM is not so rare as
one can think. On iOS and Android there are a strict memory usage restrictions, and of your app
uses more memory than allowed your app can get killed by the system. Embedded hardware systems
used in IoT, Raspberri Pi and others also have very limited amount of RAM. So you should be very
careful when porting code from desktop with gigabytes of memory to mobile platform.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&#34;why-memory-matters&#34;&gt;Why memory matters&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with a small example of &lt;a href=&#34;https://en.wikipedia.org/wiki/Unsharp_masking&#34;&gt;unsharp masking&lt;/a&gt; to illustrate the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cv::Mat source, gray, grayFloat, blurred, unsharped;
source = cv::imread(&amp;quot;/some/path/to/image.png&amp;quot;);
cv::cvtColor(m, gray, cv::COLOR_BGR2GRAY)
gray.convertTo(grayFloat, CV_32F, 1.0 / 255.0);
cv::GaussianBlur(grayFloat, blurred, cv::Size(3,3));
unsharped = blurred * 1.5f - grayFloat * 0.5f;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How much additional memory required for this piece of code to work? Let&amp;rsquo;s count:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;source = cv::imread(&amp;quot;/some/path/to/image.png&amp;quot;);         // N*M*3 bytes
cv::cvtColor(m, gray, cv::COLOR_BGR2GRAY)               // N*M bytes
gray.convertTo(grayFloat, CV_32F, 1.0 / 255.0);         // N*M*4
cv::GaussianBlur(grayFloat, blurred, cv::Size(3,3));    // N*M*4
unsharped = blurred * 1.5f - grayFloat * 0.5f;          // N*M*4   (in the best case)
                                                        // N*M*4*3 (in the worst case)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For NxM sized image we require at least sixteen (16!) times more memory in temporary variables.
Funny, but the code looks harmless for the first look. Now you can think what will happen if you
put this snippet into iOS application. Pictures made with iPhone 5S are about 3200x2400 pixels.
On such image this code will allocate 128Mb of memory!&lt;/p&gt;

&lt;p&gt;I will leave it for you as a home-work to figure out a solution to minimize memory usage by this function.
In this post I want to demonstrate how to measure memory usage in OpenCV automatically. Complex projects are
harder to analyze like example above, so you definitely not going to re-calculate it after each change.&lt;/p&gt;

&lt;h2 id=&#34;hacking-opencv&#34;&gt;Hacking OpenCV&lt;/h2&gt;

&lt;p&gt;Typically, when it comes to memory allocation tracing, we usually overload &lt;code&gt;new operator&lt;/code&gt; to intercept all
allocations. In OpenCV it becomes even easier. There is a &lt;code&gt;cv::fastMalloc&lt;/code&gt; function that is a memory allocator for
all OpenCV project. This means every &lt;code&gt;cv::Mat&lt;/code&gt; allocation use it. So our goal is to change cv::fastMalloc to &amp;lsquo;save&amp;rsquo;
allocations somewhere where we can access it in runtime.&lt;/p&gt;

&lt;p&gt;To serve this purpose, I will write a helper class to store allocations/deallocations data. For analysys purposes,
it records peak memory usage, allocations count, current memory usage and number of live objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// modules\core\include\opencv2\core.hpp
struct CV_EXPORTS MemorySnapshot
{
    //! Total amount of allocated memory.
    size_t allocatedMemory;

    //! Maximum amount of allocated memory for the whole time.
    size_t peakMemoryUsage;

    //! Maximum amount of allocated memory since last snapshot.
    size_t peakMemoryUsageSinceLastSnapshot;
    
    //! Number of memory allocations count for the whole program running time.
    size_t allocationsCount;

    //! Number of memory deallocations for the whole program running time.
    size_t deallocationsCount;
    
    //! Number of allocated objects that are still live (e.g not deallocated).
    size_t liveObjects;
};

CV_EXPORTS MemorySnapshot memorySnapshot();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An implementation of &lt;code&gt;MemoryManager&lt;/code&gt; is very trivial and can be extended to collect statistics on individual allocations.
However for my needs this implementation was more than enough:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// modules\core\alloc.cpp
class MemoryManager
{
public:
    //! Key - pointer to allocated memory, Value - it&#39;s size
    typedef std::map&amp;lt;void*, size_t&amp;gt;     AllocationTable;
    typedef std::lock_guard&amp;lt;std::mutex&amp;gt; LockType;

    void recordAlloc(void* ptr, size_t size)
    {
        LockType guard(mAllocMutex);
        mAllocatedMemory.insert(std::make_pair(ptr, size));

        mCurrentMemoryUsage += size;
        mPeakMemoryUsage = std::max(mPeakMemoryUsage, mCurrentMemoryUsage);
        mPeakMemoryUsageSinceLastSnapshot = std::max(mPeakMemoryUsageSinceLastSnapshot, mCurrentMemoryUsage);
        mAllocationsCount++;
    }

    void recordFree(void* ptr)
    {
        LockType guard(mAllocMutex);

        auto block = mAllocatedMemory.find(ptr);
        CV_Assert(block != mAllocatedMemory.end());
    
        mCurrentMemoryUsage -= block-&amp;gt;second;
        mDeallocationsCount++;
        mAllocatedMemory.erase(block);
    }

   

    static MemoryManager&amp;amp; Instance()
    {
        std::call_once(mInitFlag, []() {
            if (mInstance == nullptr)
            {
                mInstance = new MemoryManager();
            }
        });

        return *mInstance;
    }

    MemorySnapshot makeSnapshot()
    {
        LockType guard(mAllocMutex);
        
        MemorySnapshot snapshot;
        snapshot.peakMemoryUsage = mPeakMemoryUsage;
        snapshot.peakMemoryUsageSinceLastSnapshot = mPeakMemoryUsageSinceLastSnapshot;
        snapshot.allocatedMemory = mCurrentMemoryUsage;
        snapshot.allocationsCount = mAllocationsCount;
        snapshot.deallocationsCount = mDeallocationsCount;
        snapshot.liveObjects = mAllocationsCount - mDeallocationsCount;
        
        mPeakMemoryUsageSinceLastSnapshot = 0;

        return std::move(snapshot);
    }
private:

    MemoryManager()
        : mCurrentMemoryUsage(0)
        , mPeakMemoryUsage(0)
        , mPeakMemoryUsageSinceLastSnapshot(0)
        , mAllocationsCount(0)
        , mDeallocationsCount(0)
    {
    }

private:
    std::mutex      mAllocMutex;
    AllocationTable mAllocatedMemory;

    size_t          mCurrentMemoryUsage;
    size_t          mPeakMemoryUsage;
    size_t          mPeakMemoryUsageSinceLastSnapshot;

    size_t          mAllocationsCount;
    size_t          mDeallocationsCount;

    static std::once_flag  mInitFlag;
    static MemoryManager * mInstance;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it&amp;rsquo;s time to inject our MemoryManager into &lt;code&gt;cv::fastAlloc&lt;/code&gt; / &lt;code&gt;cv::fastFree&lt;/code&gt; functions and create new function &lt;code&gt;cv::memorySnaphot&lt;/code&gt; to retrieve memory snapshots:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// modules\core\alloc.cpp
void* fastMalloc( size_t size )
{
    uchar* udata = (uchar*)malloc(size + sizeof(void*) + CV_MALLOC_ALIGN);

    if(!udata)
        return OutOfMemoryError(size);

    MemoryManager::Instance().recordAlloc(udata, size);
    uchar** adata = alignPtr((uchar**)udata + 1, CV_MALLOC_ALIGN);
    adata[-1] = udata;
    return adata;
}

void fastFree(void* ptr)
{
    if(ptr)
    {
        uchar* udata = ((uchar**)ptr)[-1];
        CV_DbgAssert(udata &amp;lt; (uchar*)ptr &amp;amp;&amp;amp;
               ((uchar*)ptr - udata) &amp;lt;= (ptrdiff_t)(sizeof(void*)+CV_MALLOC_ALIGN));

        MemoryManager::Instance().recordFree(udata);
        free(udata);
    }
}

MemorySnapshot memorySnapshot()
{
    return std::move(MemoryManager::Instance().makeSnapshot());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all with hacking OpenCV. One last step is to rebuild OpenCV with any C++11 conformant compiler and we can use memory manager for analyzing our code.&lt;/p&gt;

&lt;h2 id=&#34;fun-profit&#34;&gt;Fun &amp;amp; Profit&lt;/h2&gt;

&lt;p&gt;Back to first example, we want to measure memory usage after each step. Here&amp;rsquo;s how C++ macros can help us:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cv::Mat source, gray, grayFloat, blurred, unsharped;
MEASURE_MEMORY(m = cv::imread(&amp;quot;/some/path/to/image.png&amp;quot;));
MEASURE_MEMORY(cv::cvtColor(m, gray, cv::COLOR_BGR2GRAY));
MEASURE_MEMORY(gray.convertTo(grayFloat, CV_32F, 1.0 / 255.0));
MEASURE_MEMORY(cv::GaussianBlur(grayFloat, blurred, cv::Size(5, 5), 5));
MEASURE_MEMORY(unsharped = blurred * 1.5f - grayFloat * 0.5f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;MEASURE_MEMORY&lt;/code&gt; is a helper macro defined as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define MEASURE_MEMORY(x) { size_t memOnStart = cv::memorySnapshot().allocatedMemory; x; \
                            size_t memOnEnd = cv::memorySnapshot().allocatedMemory;      \
                            std::cout &amp;lt;&amp;lt; #x &amp;lt;&amp;lt; &amp;quot;\t&amp;quot; &amp;lt;&amp;lt; memOnStart &amp;lt;&amp;lt; &amp;quot;/&amp;quot; &amp;lt;&amp;lt; memOnEnd &amp;lt;&amp;lt; std::endl; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example output is the following (The image was 3200x2400):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;m = cv::imread(&amp;quot;/some/path/to/image.png&amp;quot;)               //      743/ 23971559 +23Mb
cv::cvtColor(m, gray, cv::COLOR_BGR2GRAY)               // 23971559/ 31961831 +7.6Mb
gray.convertTo(grayFloat, CV_32F, 1.0 / 255.0)          // 31961831/ 63922919 +30Mb
cv::GaussianBlur(grayFloat, blurred, cv::Size(5, 5), 5) // 63922919/ 95884007 +30Mb
unsharped = blurred * 1.5f - grayFloat * 0.5f           // 95884007/127845095 +30Mb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, numbers are really close to predicted. This way you can measure memory usage, peak usage,
number of allocations in your program easily, spot memory-related issues and fix them before they appear on
customer&amp;rsquo;s hardware.&lt;/p&gt;

&lt;h2 id=&#34;source-code&#34;&gt;Source code&lt;/h2&gt;

&lt;p&gt;The modified OpenCV source code can be found here: &lt;a href=&#34;https://github.com/BloodAxe/opencv/tree/memory-snapshots&#34;&gt;https://github.com/BloodAxe/opencv/tree/memory-snapshots&lt;/a&gt;. Don&amp;rsquo;t forget to enable it by building OpenCV with ENABLE_MEMORY_SNAPSHOTS=YES option.&lt;/p&gt;

&lt;p&gt;I have sent pull-request to OpenCV team, so there is a chance it will be included into official OpenCV. Let&amp;rsquo;s keep fingers crossed.&lt;/p&gt;

&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;

&lt;p&gt;The code is available for use any commercial and non-commercial purposes, but please keep a credit by providing a
link to my website &lt;a href=&#34;http://computer-vision-talks.com&#34;&gt;computer-vision-talks.com&lt;/a&gt; and email &lt;a href=&#34;ekhvedchenya@gmail.com&#34;&gt;ekhvedchenya@gmail.com&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tile-based image processing</title>
      <link>https://example.com/tile-based-image-processing/</link>
      <pubDate>Thu, 04 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/tile-based-image-processing/</guid>
      <description>

&lt;p&gt;How would you design an algorithm to process 40Mpx image? 100Mpx? What about gigapixel-sized panorams? Obviously, it should differs from those that are intended for 640x480 images. Here I want to present you implementation of the very simple but powerful approach called &amp;ldquo;Tile-based image processing&amp;rdquo;. I will show you how to make this using OpenCV.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;tiles.png&#34; alt=&#34;Tile based image processing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34; /&gt;&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s define a few restrictions in order to simplify our implementation. In this tutorial I will consider a &amp;lsquo;pass-through&amp;rsquo; pipeline - when we apply some function to input image and give an output image of the same size as an output.&lt;/p&gt;

&lt;p&gt;It is possible to extend this approach to work with many input images, but for the sake of simplicity I&amp;rsquo;ll omit this for now.&lt;/p&gt;

&lt;p&gt;Consider a following algorithm:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Take a source image for RGB color space.&lt;/li&gt;
&lt;li&gt;Convert in to grayscale color space (unsigned byte).&lt;/li&gt;
&lt;li&gt;Compute Sobel derivatives (signed short).&lt;/li&gt;
&lt;li&gt;Take a Dx, Dy for each pixel and compute it&amp;rsquo;s magnitude and orientation.&lt;/li&gt;
&lt;li&gt;Leave only those, which magnitude is larger than threshold.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Using OpenCV it could look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cv::Mat source = cv::imread(&amp;quot;input.jpg&amp;quot;);
cv::Mat grayscale, dx, dy;
cv::cvtColor(source, grayscale);
cv::Sobel(grayscale, dx, 1, 0);
cv::Sobel(grayscale, dy, 0, 1);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problems-with-straighforward-implementation&#34;&gt;Problems with straighforward implementation&lt;/h2&gt;

&lt;p&gt;This routine require &lt;code&gt;N + 2 * N * sizeof(signed short)&lt;/code&gt; bytes of additional memory for straightforward implementation, where N is number of pixels in source image. Large number of intermediate buffers can cause memory issues for memory restricted devices (mobile phones, embedded systems).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;On iOS, in particular, your app might get terminated by iOS watchdog for high peak RAM usage, despite the fact you use this memory only for a temp buffers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Second issue with large amount of buffers is cache-misses. Large buffers are likely to sit near each other, therefore cache performance will be low and algorithm performance will suffer.&lt;/p&gt;

&lt;p&gt;To adress those two issues, I suggest to divide input image into &amp;ldquo;Tiles&amp;rdquo; - regions of the original image of equal size, let&amp;rsquo;s say 64x64. The processing function remains the same, but we reuse all temporary buffers and process only 64x64 pixels at one time.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;algorithm.png&#34; alt=&#34;Tile based image processing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we&amp;rsquo;re processing &lt;code&gt;1280x720&lt;/code&gt; frame, using regular approach, the total amount of
additional memory is &lt;strong&gt;4.6 megabytes&lt;/strong&gt; (&lt;code&gt;4608000&lt;/code&gt; bytes). With tile-based approach, we need only &lt;strong&gt;20 kilobytes&lt;/strong&gt; (&lt;code&gt;20480&lt;/code&gt; bytes). 20K are likely to fit entirely in L2 cache and therefore give a significant performance boost.&lt;/p&gt;

&lt;h2 id=&#34;tile-based-implementation&#34;&gt;Tile-based implementation&lt;/h2&gt;

&lt;p&gt;To implement tile-based implementation, we iterate over the image, copy tiles from source image to our local source tile, process it and write to corresponding area in the
destination image.&lt;/p&gt;

&lt;p&gt;A pseudo-code for this routine is follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;int TileSize, typename Algorithm&amp;gt;
void process(const cv::Mat&amp;amp; sourceImage, cv::Mat&amp;amp; resultImage, Algorithm algorithm) const
{
    assert(!resultImage.empty());
    assert(sourceImage.rows == resultImage.rows);
    assert(sourceImage.cols == resultImage.cols);

    const int rows = (sourceImage.rows / TileSize) + (sourceImage.rows % TileSize ? 1 : 0);
    const int cols = (sourceImage.cols / TileSize) + (sourceImage.cols % TileSize ? 1 : 0);

    cv::Mat tileInput, tileOutput;

    for (int rowTile = 0; rowTile &amp;lt; rows; rowTile++)
    {
        for (int colTile = 0; colTile &amp;lt; cols; colTile++)
        {
            copyTileFromSource(sourceImage, tileInput, rowTile, colTile);
            algorithm(tileInput, tileOutput);
            copyTileToResultImage(tileOutput, resultImage, rowTile, colTile);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I hope it&amp;rsquo;s clear to understand what is happening in code above. The &lt;code&gt;Algorithm&lt;/code&gt; here represents some algorithm that we want to run on our tiles. There are two functions &lt;code&gt;copyTileFromSource&lt;/code&gt; and &lt;code&gt;copyTileToResultImage&lt;/code&gt; that will be covered a bit later.&lt;/p&gt;

&lt;h2 id=&#34;dealing-with-out-of-tile-reads&#34;&gt;Dealing with out-of-tile reads&lt;/h2&gt;

&lt;p&gt;You may ask yourself - what should we do with border pixels? Sobel operator use neighbor pixels around each pixel. When we construct a tile shouldn&amp;rsquo;t we take this into account? Sure we are. So that&amp;rsquo;s why there is a padding parameter that controls amount of additional pixels that are added to top, left, bottom and right of the tile in order to make functions that require additional pixels work correct.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;tile_with_paddings.png&#34; alt=&#34;Tile with paddings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Padding makes tile overlap each other, but we pay this price for good cache locality.&lt;/p&gt;

&lt;p&gt;I will use a slightly modified version of code from above:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct TiledAlgorithm
{
    TiledAlgorithm(int tileSize, int padding, int borderType)
        : mTileSize(tileSize)
        , mPadding(padding)
        , mBorderType(borderType)
    {
    }

    void process(const cv::Mat&amp;amp; sourceImage, cv::Mat&amp;amp; resultImage) const
    {
        assert(!resultImage.empty());
        assert(sourceImage.rows == resultImage.rows);
        assert(sourceImage.cols == resultImage.cols);

        int rows = (sourceImage.rows / mTileSize) + (sourceImage.rows % mTileSize ? 1 : 0);
        int cols = (sourceImage.cols / mTileSize) + (sourceImage.cols % mTileSize ? 1 : 0);

        cv::Mat tileInput, tileOutput;

        for (int rowTile = 0; rowTile &amp;lt; rows; rowTile++)
        {
            for (int colTile = 0; colTile &amp;lt; cols; colTile++)
            {
                cv::Rect srcTile(colTile * mTileSize - mPadding, 
                                 rowTile * mTileSize - mPadding, 
                                 mTileSize + 2 * mPadding, 
                                 mTileSize + 2 * mPadding);

                cv::Rect dstTile(colTile * mTileSize,            
                                 rowTile * mTileSize, 
                                 mTileSize, 
                                 mTileSize);

                copySourceTile(sourceImage, tileInput, srcTile);
                processTileImpl(tileInput, tileOutput);
                copyTileToResultImage(tileOutput, resultImage, dstTile);
            }
        }
    }

protected:
    virtual void processTileImpl(const cv::Mat&amp;amp; srcTile, cv::Mat&amp;amp; dstTile) const = 0;
    
    void copySourceTile(const cv::Mat&amp;amp; src, cv::Mat&amp;amp; srcTile, cv::Rect &amp;amp;tile) const;
    void copyTileToResultImage(const cv::Mat&amp;amp; tileImage, cv::Mat&amp;amp; resultImage, cv::Rect resultRoi);

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;processing_with_paddings.png&#34; alt=&#34;Processing with paddings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To fill a tile with source image we should check whether tile is close to image border. In this case OpenCV will come to help with cv::copyMakeBorder function that helps us to fill the missing pixels with given border fill method. If tile including paddings are entirely in the image boundary, it&amp;rsquo;s enough to just copy image region to a tile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void copySourceTile(const cv::Mat&amp;amp; src, cv::Mat&amp;amp; srcTile, cv::Rect &amp;amp;tile)
{
    auto tl = tile.tl();
    auto br = tile.br();

    cv::Point tloffset, broffset;

    //Take care of border cases
    if (tile.x &amp;lt; 0)
    {
        tloffset.x = -tile.x;
        tile.x = 0;
    }

    if (tile.y &amp;lt; 0)
    {
        tloffset.y = -tile.y;
        tile.y = 0;
    }

    if (br.x &amp;gt;= src.cols)
    {
        broffset.x = br.x - src.cols + 1;
        tile.width -= broffset.x;
    }

    if (br.y &amp;gt;= src.rows)
    {
        broffset.y = br.y - src.rows + 1;
        tile.height -= broffset.y;
    }

    // If any of the tile sides exceed source image boundary we must use copyMakeBorder to make proper paddings for this side
    if (tloffset.x &amp;gt; 0 || tloffset.y &amp;gt; 0 || broffset.x &amp;gt; 0 || broffset.y &amp;gt; 0)
    {
        cv::Rect paddedTile(tile.tl(), tile.br());
        assert(paddedTile.x &amp;gt;= 0);
        assert(paddedTile.y &amp;gt;= 0);
        assert(paddedTile.br().x &amp;lt; src.cols);
        assert(paddedTile.br().y &amp;lt; src.rows);

        cv::copyMakeBorder(src(paddedTile), srcTile, tloffset.y, broffset.y, tloffset.x, broffset.x, mBorderType);
    }
    else
    {
        // Entire tile (with paddings lies inside image and it&#39;s safe to just take a region:
        src(tile).copyTo(srcTile);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For non-zero padding case we add additional pixels to source tile, therefore it has effective width and height of &lt;code&gt;TileSize + Padding + Padding&lt;/code&gt;, but after processing we write only central segment of the tile of size &lt;code&gt;TileSize x TileSize&lt;/code&gt; to destination image. In case of Sobel, we need a padding of &lt;code&gt;1&lt;/code&gt;, because Sobel uses 3x3 kernel by default.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void copyTileToResultImage(const cv::Mat&amp;amp; tileImage, cv::Mat&amp;amp; resultImage, cv::Rect resultRoi)
{
    cv::Rect srcTile(mPadding, mPadding, mTileSize, mTileSize);

    auto br = resultRoi.br();

    if (br.x &amp;gt;= resultImage.cols)
    {
        resultRoi.width -= br.x - resultImage.cols;
        srcTile.width -= br.x - resultImage.cols;
    }

    if (br.y &amp;gt;= resultImage.rows)
    {
        resultRoi.height -= br.y - resultImage.rows;
        srcTile.height -= br.y - resultImage.rows;
    }

    cv::Mat tileView = tileImage(srcTile);
    cv::Mat dstView = resultImage(resultRoi);

    assert(tileView.rows == dstView.rows);
    assert(tileView.cols == dstView.cols);

    tileView.copyTo(dstView);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;application&#34;&gt;Application&lt;/h2&gt;

&lt;p&gt;This approach can be used when you need to guarantee low-memory footprint of your algorithm or you want to use data locality without changing a lot in your code. In this
case I suggest to pre-allocate data buffers as a continuous block of memory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Our algorithm need three intermediate buffers: a,b,c that
// we want to store close to each other
class MyAlgorithm : public TiledAlgorithm
{
public:
    MyAlgorithm(int tileSize, int padding)
    {
        int size = tileSize + padding * 2;

        // Allocate all buffer as continuous array
        mBuffer.create(size * 3, size, CV_8UC1);
            
        // Create views to sub-regions of mBuffer
        a = mBuffer.rowRange(0,      size);
        b = mBuffer.rowRange(size,   2*size);
        c = mBuffer.rowRange(2*size, 3*size);
    }

private:
    cv::Mat mBuffer;

    cv::Mat a, b c;
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Did you know, that JPEG-2000 coded use tile-based encoding and it allows this codec to retrieve (decode) an arbitrary region of the image? Also, tiles are widely used in aerial photography to stich images.&lt;/p&gt;

&lt;p&gt;I hope you find this post interesting. Pleas let me know on which topics you would like to see in my blog. Feel free to drop a ping on &lt;a href=&#34;https://twitter.com/cvtalks&#34;&gt;@cvtalks&lt;/a&gt; or leave a comment. Thanks!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My awesome project</title>
      <link>https://example.com/project/my-awesome-project/</link>
      <pubDate>Tue, 18 Nov 2014 02:13:50 +0000</pubDate>
      
      <guid>https://example.com/project/my-awesome-project/</guid>
      <description>

&lt;h2 id=&#34;about-project&#34;&gt;About project&lt;/h2&gt;

&lt;p&gt;Aenean ipsum justo, semper eu nisl ut, pretium tincidunt sem. Praesent et diam sit amet lacus lobortis dictum a id lacus. Quisque hendrerit sit amet turpis eu varius. Ut id lorem ac felis ultrices tincidunt. Pellentesque consequat arcu ac fringilla imperdiet. Phasellus pellentesque, sapien non pulvinar blandit, sapien ante aliquet felis, vel porttitor sapien ante in lacus. Fusce non urna aliquet, malesuada nibh vel, luctus urna. Phasellus ut lacus molestie, varius purus quis, malesuada lorem.&lt;/p&gt;

&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get -u -v github.com/spf13/hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;docs&#34;&gt;Docs&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/spf13/hugo&#34;&gt;https://godoc.org/github.com/spf13/hugo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Image processing in your browser - Unit Test automation</title>
      <link>https://example.com/image-processing-in-your-browser-unit-test-automation/</link>
      <pubDate>Fri, 31 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/image-processing-in-your-browser-unit-test-automation/</guid>
      <description>&lt;p&gt;JavaScript. Do you like debug JavaScript code? I hate it. Literally.
What what if you have to? In this post I&amp;rsquo;m going to show you how to
simplify your life by automating unit testing of the JavaScript code
for the browser.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;monkeys.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To get things more interesting - let&amp;rsquo;s automate unit-testing of the
image processing library called &lt;a href=&#34;http://inspirit.github.io/jsfeat/&#34;&gt;JSFeat&lt;/a&gt;. JSFeat provides a
JavaScript implementation of the basic image processing operations
that let you to process images in your browser and build sophisticated
algorithms. &lt;strong&gt;It&amp;rsquo;s like OpenCV for web-browser&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/BloodAxe/jsfeat&#34;&gt;source code&lt;/a&gt; for this tutorial is available on my Github page: &lt;a href=&#34;https://github.com/BloodAxe/jsfeat&#34;&gt;https://github.com/BloodAxe/jsfeat&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Typically, when we test C++ software, we end up with test framework of your
choise and test runner. It can be continuous integration server like Jenkins
in your company or public Travic-CI service for open-source project.&lt;/p&gt;

&lt;p&gt;With browser JavaScript things gets more complicated. I&amp;rsquo;m not talking about
JS unit-test frameworks - &lt;a href=&#34;https://github.com/mochajs/mocha&#34;&gt;mocha&lt;/a&gt; is more than enough. I&amp;rsquo;m talking about
browser testing itself. Basically you have to open a webpage in your browser to
invoke a test cases. Manually. Ew!&lt;/p&gt;

&lt;p&gt;Moreover, due to browser sandbox, you are not allowed to access canvas data for
local files. In practice it means that code like showed below &lt;strong&gt;won&amp;rsquo;t work if you
open a HTML page as a local file&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var img = new Image();
img.src = &#39;dummy.jpg&#39;;
img.onload = function() {
    // This will never happen
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will have to setup a local HTTP server to serve these tests pages to get this
works. One simple way to do it by using python: &lt;code&gt;python -m SimpleHTTPServer 8000&lt;/code&gt; will
do the job. However it&amp;rsquo;s only a partial solution.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s imagine that you have a lot of these tests. Would you open each page
individually, watch how they run and wait to analyze their results? No doubts,
you can do it, but this is not automated testing in any way.&lt;/p&gt;

&lt;p&gt;To recap, here are a list of problems that exists in browser JS testing:
 - A test framework
 - Have to open test pages in a browser
 - Hard to automate and collect results
 - Need local webserver&lt;/p&gt;

&lt;p&gt;Since I&amp;rsquo;m used to Mocha, i will use it. However it&amp;rsquo;s not obligatory and you can chose any other test framework you like. But as you will see later, with Mocha it&amp;rsquo;s really simple. ith mocha you can write your scripts like showed below. This is a real test I wrote as an example for JSFeat:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Source test/test_grayscale.js
&#39;use strict&#39;;

describe(&#39;jsfeat&#39;, function(){

  describe(&#39;imgproc&#39;, function(){

    it(&#39;grayscale&#39;, function(done) {

      var img = new Image();
      img.src = &#39;lena.png&#39;;
      img.onload = function() {

        var width = img.width;
        var height = img.height;

        var canvas = document.createElement(&#39;canvas&#39;);
        var context2d = canvas.getContext(&#39;2d&#39;);

        context2d.drawImage(img, 0, 0, width, height);
        var image_data = context2d.getImageData(0, 0, width, height);
 
        var gray_img = new jsfeat.matrix_t(width, height, jsfeat.U8_t | jsfeat.C1_t);
        var code = jsfeat.COLOR_RGBA2GRAY;

        jsfeat.imgproc.grayscale(image_data.data, width, height, gray_img, code);
        done();
      };

    });

  });
   
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a really powerful tool in Nodejs world called [Grunt][grunt] that we will use
to automate tasks like JavaScript static code checking, minification and testing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install -g grunt-cli
npm install grunt --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A headless browser is a full-featured browser engine without graphical interface. It was designed to simulate a real browser including DOM and JavaScript. The most important headless browser is &lt;a href=&#34;http://phantomjs.org/&#34;&gt;PhantomJS&lt;/a&gt;. I found that it works like a charm for this task. With phantomjs we can run arbitrary HTML page inside and execute JavaScript code. This tool let&amp;rsquo;s us to get rid of the manual tabs openning.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// script.js:
// Simple Javascript example

console.log(&#39;Loading a web page&#39;);
var page = require(&#39;webpage&#39;).create();
var url = &#39;http://www.phantomjs.org/&#39;;
page.open(url, function (status) {
  //Page is loaded!
  phantom.exit();
});

phantomjs script.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PhantomJS and Mocha are already connected together in a single grunt task called &lt;a href=&#34;https://github.com/jdcataldo/grunt-mocha-phantomjs&#34;&gt;grunt-mocha-phantomjs&lt;/a&gt;. And we use &lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-connect&#34;&gt;grunt-contrib-connect&lt;/a&gt; to host a local webserver.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install grunt-mocha-phantomjs --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This extension does exactly what we need: it starts a local webserver, open page in phantomjs and run JS test cases.
With help of it, we are able to run all our tests using simple command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grunt test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s an example output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Running &amp;quot;concat:jsfeat&amp;quot; (concat) task
File build/jsfeat.js created.

Running &amp;quot;uglify:build&amp;quot; (uglify) task
&amp;gt;&amp;gt; 1 file created.

Running &amp;quot;connect:server&amp;quot; (connect) task
Started connect web server on http://0.0.0.0:8000

Running &amp;quot;mocha_phantomjs:all&amp;quot; (mocha_phantomjs) task


  jsfeat
    imgproc
      ✓ grayscale 


  1 passing (41ms)


Done, without errors.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Within this setup you are now able to automate testing of JavaScript code that require interaction with HTML5 Canvas features. This way I test the code that I write for browser image processing. I hope you enjoyed this post and I&amp;rsquo;m looking forward to see your questions and mentions in a comments!&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/BloodAxe/jsfeat&#34;&gt;source code&lt;/a&gt; for this tutorial is available on my Github page: &lt;a href=&#34;https://github.com/BloodAxe/jsfeat&#34;&gt;https://github.com/BloodAxe/jsfeat&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computer Vision Digest - September 2014</title>
      <link>https://example.com/computer-vision-digest-september-2014/</link>
      <pubDate>Wed, 01 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/computer-vision-digest-september-2014/</guid>
      <description>

&lt;p&gt;Third &lt;a href=&#34;https://example.com/tags/digest.html&#34;&gt;computer vision digest&lt;/a&gt;. Your monthly portion of news in computer vision for September 2014.&lt;/p&gt;

&lt;p&gt;In this issue:
 - &lt;a href=&#34;#1&#34;&gt;Real-time face 3D model reconstruction&lt;/a&gt;
 - &lt;a href=&#34;#1&#34;&gt;Image color correction and contrast enhancement&lt;/a&gt;
 - &lt;a href=&#34;#3&#34;&gt;Robust Optimization Techniques in Computer Vision&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Previous issues:
 - &lt;a href=&#34;https://example.com/articles/2014-05-computer-vision-digest/&#34;&gt;Computer Vision Digest (May 2014)&lt;/a&gt;
 - &lt;a href=&#34;https://example.com/articles/2014-06-computer-vision-digest/&#34;&gt;Computer Vision Digest (June 2014)&lt;/a&gt;
 - &lt;a href=&#34;https://example.com/articles/computer-vision-digest-august-2014/&#34;&gt;Computer Vision Digest (August 2014)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
Feel free to leave your suggestions on interesting materials in post comments 
or via Twitter by mentioning [@cvtalks](https://twitter.com/cvtalks). 
Best links will be included into next digest!
&lt;/div&gt;

&lt;p&gt;&lt;span class=&#34;more clearfix&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;real-time-face-3d-model-reconstruction&#34;&gt;Real-time face 3D model reconstruction&lt;/h2&gt;

&lt;p&gt;Researchers from the University of Washington prepared interesting presentation for the European Conference on Computer Vision (ECCV-2014). It is a real-time &lt;a href=&#34;http://grail.cs.washington.edu/projects/totalmoving/&#34;&gt;3D face reconstruction from the video&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;15a03e37860948f9b2c4925b3c311c45.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Using the video from YouTube, the program automatically builds highly detailed face 3D-model for each video frame.&lt;/p&gt;

&lt;p&gt;This is a very impressive result, given the complexity of the problem, because the facial expressions of the human face is very complex. For emotion recognition, it is important to see the exact position of the eyes, bending eyebrows, wrinkles. The smallest error in reconstructed 3D-model is highly noticeable.&lt;/p&gt;

&lt;iframe width=&#34;800&#34; height=&#34;600&#34; src=&#34;//www.youtube.com/embed/C1iLVAUiC7s&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;The vast majority of other programs for face 3D-tracking uses blend shapes method, when the shape of the object changes, &amp;ldquo;flowing&amp;rdquo; from one state to another. The method of smooth deformations has lack of the small details that are so important for the perception of faces. The authors of the new algorithm abandoned this approach.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;2639b10e54684d11b684d3257c8f400c.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;On the other hand, although the frame-independent reconstruction create a &amp;ldquo;separate&amp;rdquo; 3D mode from each frame, when you play on the &lt;sup&gt;30&lt;/sup&gt;&amp;frasl;&lt;sub&gt;60&lt;/sub&gt; frames per second, the result should be more realistic than in the case of a smooth modification.&lt;/p&gt;

&lt;p&gt;And more. Unlike other technologies, it does not require human involvement in a test of a movie. Instead, a large archive of his photographs in different lighting conditions and poses, this method use video footrage that is tracked with optical flow (3D optical flow). Author research say that in our time for each person collected a large archive of photographs that can be used to reconstruct it&amp;rsquo;s face.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;28b4d17c1c65450faa683cc1afeddd89.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Source: &lt;a href=&#34;http://habrahabr.ru/post/237827/&#34;&gt;http://habrahabr.ru/post/237827/&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;image-color-correction-and-contrast-enhancement&#34;&gt;Image color correction and contrast enhancement&lt;/h2&gt;

&lt;p&gt;A friend of mine shared a link to slideshare to the exhaustive research and analysis of color correction and contrast enchancement algorithms. How many of these have you worked with? I was impressed on how much algorithms has been developed so far. Just watch these slides, I bet - you&amp;rsquo;ll find new algorithms you&amp;rsquo;ve never heard about. Cheers to Yu Huang for collecting them for us!&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/28271598?rel=0&#34; width=&#34;597&#34; height=&#34;486&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;https://www.slideshare.net/yuhuang/image-color-correction-contrast-adjustment&#34; title=&#34;Image color correction and contrast enhancement&#34; target=&#34;_blank&#34;&gt;Image color correction and contrast enhancement&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;http://www.slideshare.net/yuhuang&#34; target=&#34;_blank&#34;&gt;Yu Huang&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a name=&#34;3&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;robust-optimization-techniques-in-computer-vision&#34;&gt;Robust Optimization Techniques in Computer Vision&lt;/h2&gt;

&lt;div class=&#34;alert alert-danger&#34; role=&#34;alert&#34;&gt;
    &lt;strong&gt;Math warning.&lt;/strong&gt; Do not read this section unless you understand what damping function is and what is LevMar.
&lt;/div&gt;

&lt;p&gt;I&amp;rsquo;ve found nice slides from the ECCV 2014 workshop on non-linear optimization problems that happen in computer vision.&lt;/p&gt;

&lt;p&gt;Course description&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&#34;pull-left&#34;&gt;
![nl](nl.png)
&lt;/div&gt;

&lt;p&gt;Many important problems in computer vision, such as structure from motion and image registration, involve model estimation in presence of a significant number of outliers. Due to the outliers, simple estimation techniques such as least squares perform very poorly. To deal with this issue, vision researchers have come up with a number of techniques that are robust to outliers, such as Hough transform and RANSAC (random sample consensus). These methods will be analyzed with respect to statistical modeling, worst-case and average exectution times and how to choose the balance between the number of outliers and the number of inliers. Apart from these classical techniques we will also describe recent advances in robust model estimation. This includes sampling based techniques with guaranteed optimality for low-dimensional problems and optimization of semi-robust norms for high-dimensional problems. We will see how to solve low-dimensional estimation problems with over 99% outliers in a few seconds, as well as how to detect outliers in structure from motion problems with thousands of variables.
Topics&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www2.maths.lth.se/matematiklth/personal/fredrik/Session1.pdf&#34;&gt;Session 1&lt;/a&gt;: Statistical models of robust regression. Introduction, motivations and applications. Relation to robust statistics. Occasional vs. frequent large-scale measurement noise (outliers). Low- vs. high-dimensional model estimation. Optimal vs. approximate methods. Multiple model fitting. Computational complexity.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www2.maths.lth.se/matematiklth/personal/fredrik/Session2.pdf&#34;&gt;Session 2&lt;/a&gt;: Robust estimation with low-dimensional models. Hough transform. M-estimators. RANSAC and its variants. Branch and bound methods. Optimal methods. Fast approximate methods. Applications: Feature-based registration, multiple-view geometry, image-based localization.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www2.maths.lth.se/matematiklth/personal/fredrik/Session3.pdf&#34;&gt;Session 3&lt;/a&gt;: Robust estimation with high-dimensional models. Robust norms and convex optimization. L_infinity-norm optimization with outliers. L_1-norm optimization on manifolds. Applications: Multiple-view geometry, large-scale structure-from-motion and subspace estimation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can read it here: &lt;a href=&#34;http://www2.maths.lth.se/matematiklth/personal/fredrik/eccv2014_tutorial.html&#34;&gt;http://www2.maths.lth.se/matematiklth/personal/fredrik/eccv2014_tutorial.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>https://example.com/2014/09/28/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 02:13:50 +0000</pubDate>
      
      <guid>https://example.com/2014/09/28/creating-a-new-theme/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start with creating a new site with a very basic template. Then we&amp;rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.&lt;/p&gt;

&lt;p&gt;In this tutorial, commands that you enter will start with the &amp;ldquo;$&amp;rdquo; prompt. The output will follow. Lines that start with &amp;ldquo;#&amp;rdquo; are comments that I&amp;rsquo;ve added to explain a point. When I show updates to a file, the &amp;ldquo;:wq&amp;rdquo; on the last line means to save the file.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## this is a comment
$ echo this is a command
this is a command

## edit the file
$vi foo.md
+++
date = &amp;quot;2014-09-28&amp;quot;
title = &amp;quot;creating a new theme&amp;quot;
+++

bah and humbug
:wq

## show it
$ cat foo.md
+++
date = &amp;quot;2014-09-28&amp;quot;
title = &amp;quot;creating a new theme&amp;quot;
+++

bah and humbug
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;some-definitions&#34;&gt;Some Definitions&lt;/h2&gt;

&lt;p&gt;There are a few concepts that you need to understand before creating a theme.&lt;/p&gt;

&lt;h3 id=&#34;skins&#34;&gt;Skins&lt;/h3&gt;

&lt;p&gt;Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.&lt;/p&gt;

&lt;p&gt;You have two ways to create a skin. The simplest way is to create it in the &lt;code&gt;layouts/&lt;/code&gt; directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the &lt;code&gt;layouts/&lt;/code&gt; directory so it will always find the skin.&lt;/p&gt;

&lt;p&gt;Your second choice is to create it in a sub-directory of the &lt;code&gt;themes/&lt;/code&gt; directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?&lt;/p&gt;

&lt;p&gt;The difference between creating a skin in &lt;code&gt;layouts/&lt;/code&gt; and creating it in &lt;code&gt;themes/&lt;/code&gt; is very subtle. A skin in &lt;code&gt;layouts/&lt;/code&gt; can’t be customized without updating the templates and static files that it is built from. A skin created in &lt;code&gt;themes/&lt;/code&gt;, on the other hand, can be and that makes it easier for other people to use it.&lt;/p&gt;

&lt;p&gt;The rest of this tutorial will call a skin created in the &lt;code&gt;themes/&lt;/code&gt; directory a theme.&lt;/p&gt;

&lt;p&gt;Note that you can use this tutorial to create a skin in the &lt;code&gt;layouts/&lt;/code&gt; directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.&lt;/p&gt;

&lt;h3 id=&#34;the-home-page&#34;&gt;The Home Page&lt;/h3&gt;

&lt;p&gt;The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.&lt;/p&gt;

&lt;h3 id=&#34;site-configuration-file&#34;&gt;Site Configuration File&lt;/h3&gt;

&lt;p&gt;When Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.&lt;/p&gt;

&lt;p&gt;Hugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your &lt;code&gt;content/&lt;/code&gt; directory and template files in your &lt;code&gt;themes/&lt;/code&gt; directory. It will create HTML files in your &lt;code&gt;public/&lt;/code&gt; directory. You can change this by specifying alternate locations in the configuration file.&lt;/p&gt;

&lt;h3 id=&#34;content&#34;&gt;Content&lt;/h3&gt;

&lt;p&gt;Content is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.&lt;/p&gt;

&lt;h4 id=&#34;front-matter&#34;&gt;Front Matter&lt;/h4&gt;

&lt;p&gt;The front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “&lt;code&gt;+++&lt;/code&gt;”, YAML by “&lt;code&gt;---&lt;/code&gt;”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.&lt;/p&gt;

&lt;p&gt;The information in the front matter is passed into the template before the content is rendered into HTML.&lt;/p&gt;

&lt;h4 id=&#34;markdown&#34;&gt;Markdown&lt;/h4&gt;

&lt;p&gt;Content is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.&lt;/p&gt;

&lt;h3 id=&#34;template-files&#34;&gt;Template Files&lt;/h3&gt;

&lt;p&gt;Hugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it&amp;rsquo;s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.&lt;/p&gt;

&lt;p&gt;There are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.&lt;/p&gt;

&lt;p&gt;Hugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.&lt;/p&gt;

&lt;p&gt;Please note that you can use the front matter to influence Hugo’s choice of templates.&lt;/p&gt;

&lt;h4 id=&#34;single-template&#34;&gt;Single Template&lt;/h4&gt;

&lt;p&gt;A single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.&lt;/p&gt;

&lt;h4 id=&#34;list-template&#34;&gt;List Template&lt;/h4&gt;

&lt;p&gt;A list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.&lt;/p&gt;

&lt;p&gt;The homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.&lt;/p&gt;

&lt;h4 id=&#34;partial-template&#34;&gt;Partial Template&lt;/h4&gt;

&lt;p&gt;A partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.&lt;/p&gt;

&lt;h2 id=&#34;create-a-new-site&#34;&gt;Create a New Site&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s use Hugo to create a new web site. I&amp;rsquo;m a Mac user, so I&amp;rsquo;ll create mine in my home directory, in the Sites folder. If you&amp;rsquo;re using Linux, you might have to create the folder first.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;new site&amp;rdquo; command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site ~/Sites/zafta
$ cd ~/Sites/zafta
$ ls -l
total 8
drwxr-xr-x  7 quoha  staff  238 Sep 29 16:49 .
drwxr-xr-x  3 quoha  staff  102 Sep 29 16:49 ..
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 archetypes
-rw-r--r--  1 quoha  staff   82 Sep 29 16:49 config.toml
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 content
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 layouts
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 static
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take a look in the content/ directory to confirm that it is empty.&lt;/p&gt;

&lt;p&gt;The other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That&amp;rsquo;s a topic for a different tutorial, so please ignore them for now.&lt;/p&gt;

&lt;h3 id=&#34;generate-the-html-for-the-new-site&#34;&gt;Generate the HTML For the New Site&lt;/h3&gt;

&lt;p&gt;Running the &lt;code&gt;hugo&lt;/code&gt; command with no options will read all the available content and generate the HTML files. It will also copy all static files (that&amp;rsquo;s everything that&amp;rsquo;s not content). Since we have an empty site, it won&amp;rsquo;t do much, but it will do it very quickly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo --verbose
INFO: 2014/09/29 Using config file: config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]
WARN: 2014/09/29 Unable to locate layout: [404.html]
0 draft content
0 future content
0 pages created
0 tags created
0 categories created
in 2 ms
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;&lt;code&gt;--verbose&lt;/code&gt;&amp;rdquo; flag gives extra information that will be helpful when we build the template. Every line of the output that starts with &amp;ldquo;INFO:&amp;rdquo; or &amp;ldquo;WARN:&amp;rdquo; is present because we used that flag. The lines that start with &amp;ldquo;WARN:&amp;rdquo; are warning messages. We&amp;rsquo;ll go over them later.&lt;/p&gt;

&lt;p&gt;We can verify that the command worked by looking at the directory again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
total 8
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 archetypes
-rw-r--r--  1 quoha  staff   82 Sep 29 16:49 config.toml
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 content
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 layouts
drwxr-xr-x  4 quoha  staff  136 Sep 29 17:02 public
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 static
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See that new public/ directory? Hugo placed all generated content there. When you&amp;rsquo;re ready to publish your web site, that&amp;rsquo;s the place to start. For now, though, let&amp;rsquo;s just confirm that we have what we&amp;rsquo;d expect from a site with no content.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l public
total 16
-rw-r--r--  1 quoha  staff  416 Sep 29 17:02 index.xml
-rw-r--r--  1 quoha  staff  262 Sep 29 17:02 sitemap.xml
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo created two XML files, which is standard, but there are no HTML files.&lt;/p&gt;

&lt;h3 id=&#34;test-the-new-site&#34;&gt;Test the New Site&lt;/h3&gt;

&lt;p&gt;Verify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the &amp;ldquo;server&amp;rdquo; command. If it is successful, you will see output similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]
WARN: 2014/09/29 Unable to locate layout: [404.html]
0 draft content
0 future content
0 pages created
0 tags created
0 categories created
in 2 ms
Serving pages from /Users/quoha/Sites/zafta/public
Web Server is available at http://localhost:1313
Press Ctrl+C to stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Connect to the listed URL (it&amp;rsquo;s on the line that starts with &amp;ldquo;Web Server&amp;rdquo;). If everything is working correctly, you should get a page that shows the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index.xml
sitemap.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a listing of your public/ directory. Hugo didn&amp;rsquo;t create a home page because our site has no content. When there&amp;rsquo;s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.&lt;/p&gt;

&lt;p&gt;Let’s go back and look at those warnings again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]
WARN: 2014/09/29 Unable to locate layout: [404.html]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.&lt;/p&gt;

&lt;p&gt;Now for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.&lt;/p&gt;

&lt;p&gt;I like that the verbose flag causes Hugo to list the files that it&amp;rsquo;s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we&amp;rsquo;ll cover later that explain the names and paths. For now, just remember that Hugo couldn&amp;rsquo;t find a template for the home page and it told you so.&lt;/p&gt;

&lt;p&gt;At this point, you&amp;rsquo;ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.&lt;/p&gt;

&lt;h2 id=&#34;create-a-new-theme&#34;&gt;Create a New Theme&lt;/h2&gt;

&lt;p&gt;Hugo doesn&amp;rsquo;t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re going to create a new theme called &amp;ldquo;zafta.&amp;rdquo; Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.&lt;/p&gt;

&lt;p&gt;All themes have opinions on content and layout. For example, Zafta uses &amp;ldquo;post&amp;rdquo; over &amp;ldquo;blog&amp;rdquo;. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.&lt;/p&gt;

&lt;h3 id=&#34;create-a-skeleton&#34;&gt;Create a Skeleton&lt;/h3&gt;

&lt;p&gt;Use the hugo &amp;ldquo;new&amp;rdquo; command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new theme zafta

$ ls -l
total 8
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 archetypes
-rw-r--r--  1 quoha  staff   82 Sep 29 16:49 config.toml
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 content
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 layouts
drwxr-xr-x  4 quoha  staff  136 Sep 29 17:02 public
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 static
drwxr-xr-x  3 quoha  staff  102 Sep 29 17:31 themes

$ find themes -type f | xargs ls -l
-rw-r--r--  1 quoha  staff  1081 Sep 29 17:31 themes/zafta/LICENSE.md
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/archetypes/default.md
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/_default/list.html
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/_default/single.html
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/index.html
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/partials/header.html
-rw-r--r--  1 quoha  staff    93 Sep 29 17:31 themes/zafta/theme.toml
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.&lt;/p&gt;

&lt;p&gt;Please take a minute to fill out the theme.toml and LICENSE.md files. They&amp;rsquo;re optional, but if you&amp;rsquo;re going to be distributing your theme, it tells the world who to praise (or blame). It&amp;rsquo;s also nice to declare the license so that people will know how they can use the theme.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/theme.toml
author = &amp;quot;michael d henderson&amp;quot;
description = &amp;quot;a minimal working template&amp;quot;
license = &amp;quot;MIT&amp;quot;
name = &amp;quot;zafta&amp;quot;
source_repo = &amp;quot;&amp;quot;
tags = [&amp;quot;tags&amp;quot;, &amp;quot;categories&amp;quot;]
:wq

## also edit themes/zafta/LICENSE.md and change
## the bit that says &amp;quot;YOUR_NAME_HERE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the the skeleton&amp;rsquo;s template files are empty. Don&amp;rsquo;t worry, we&amp;rsquo;ll be changing that shortly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find themes/zafta -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/_default/list.html
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/_default/single.html
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/index.html
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/partials/header.html
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;update-the-configuration-file-to-use-the-theme&#34;&gt;Update the Configuration File to Use the Theme&lt;/h3&gt;

&lt;p&gt;Now that we&amp;rsquo;ve got a theme to work with, it&amp;rsquo;s a good idea to add the theme name to the configuration file. This is optional, because you can always add &amp;ldquo;-t zafta&amp;rdquo; on all your commands. I like to put it the configuration file because I like shorter command lines. If you don&amp;rsquo;t put it in the configuration file or specify it on the command line, you won&amp;rsquo;t use the template that you&amp;rsquo;re expecting to.&lt;/p&gt;

&lt;p&gt;Edit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi config.toml
theme = &amp;quot;zafta&amp;quot;
baseurl = &amp;quot;&amp;quot;
languageCode = &amp;quot;en-us&amp;quot;
title = &amp;quot;zafta - totally refreshing&amp;quot;
MetaDataFormat = &amp;quot;toml&amp;quot;
:wq

$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;generate-the-site&#34;&gt;Generate the Site&lt;/h3&gt;

&lt;p&gt;Now that we have an empty theme, let&amp;rsquo;s generate the site again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content
0 future content
0 pages created
0 tags created
0 categories created
in 2 ms
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Did you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme&amp;rsquo;s directory.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check the public/ directory to see what Hugo&amp;rsquo;s created.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l public
total 16
drwxr-xr-x  2 quoha  staff   68 Sep 29 17:56 css
-rw-r--r--  1 quoha  staff    0 Sep 29 17:56 index.html
-rw-r--r--  1 quoha  staff  407 Sep 29 17:56 index.xml
drwxr-xr-x  2 quoha  staff   68 Sep 29 17:56 js
-rw-r--r--  1 quoha  staff  243 Sep 29 17:56 sitemap.xml
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice four things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hugo created a home page. This is the file public/index.html.&lt;/li&gt;
&lt;li&gt;Hugo created a css/ directory.&lt;/li&gt;
&lt;li&gt;Hugo created a js/ directory.&lt;/li&gt;
&lt;li&gt;Hugo claimed that it created 0 pages. It created a file and copied over static files, but didn&amp;rsquo;t create any pages. That&amp;rsquo;s because it considers a &amp;ldquo;page&amp;rdquo; to be a file created directly from a content file. It doesn&amp;rsquo;t count things like the index.html files that it creates automatically.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;the-home-page-1&#34;&gt;The Home Page&lt;/h4&gt;

&lt;p&gt;Hugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo&amp;rsquo;s warning message shows that it looks for three different templates:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it can&amp;rsquo;t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.&lt;/p&gt;

&lt;p&gt;When Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find . -name index.html | xargs ls -l
-rw-r--r--  1 quoha  staff  0 Sep 29 20:21 ./public/index.html
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 ./themes/zafta/layouts/index.html
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-magic-of-static&#34;&gt;The Magic of Static&lt;/h4&gt;

&lt;p&gt;Hugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.&lt;/p&gt;

&lt;p&gt;Hugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo&amp;rsquo;s opinion is that you&amp;rsquo;ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don&amp;rsquo;t like that, you can change the directory names in your theme directory or even delete them completely. Hugo&amp;rsquo;s nice enough to offer its opinion, then behave nicely if you disagree.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find themes/zafta -type d | xargs ls -ld
drwxr-xr-x  7 quoha  staff  238 Sep 29 17:38 themes/zafta
drwxr-xr-x  3 quoha  staff  102 Sep 29 17:31 themes/zafta/archetypes
drwxr-xr-x  5 quoha  staff  170 Sep 29 17:31 themes/zafta/layouts
drwxr-xr-x  4 quoha  staff  136 Sep 29 17:31 themes/zafta/layouts/_default
drwxr-xr-x  4 quoha  staff  136 Sep 29 17:31 themes/zafta/layouts/partials
drwxr-xr-x  4 quoha  staff  136 Sep 29 17:31 themes/zafta/static
drwxr-xr-x  2 quoha  staff   68 Sep 29 17:31 themes/zafta/static/css
drwxr-xr-x  2 quoha  staff   68 Sep 29 17:31 themes/zafta/static/js
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-theme-development-cycle&#34;&gt;The Theme Development Cycle&lt;/h2&gt;

&lt;p&gt;When you&amp;rsquo;re working on a theme, you will make changes in the theme&amp;rsquo;s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Purge the public/ directory.&lt;/li&gt;
&lt;li&gt;Run the built in web server in watch mode.&lt;/li&gt;
&lt;li&gt;Open your site in a browser.&lt;/li&gt;
&lt;li&gt;Update the theme.&lt;/li&gt;
&lt;li&gt;Glance at your browser window to see changes.&lt;/li&gt;
&lt;li&gt;Return to step 4.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.&lt;/p&gt;

&lt;p&gt;Check the main Hugo site for information on using Git with Hugo.&lt;/p&gt;

&lt;h3 id=&#34;purge-the-public-directory&#34;&gt;Purge the public/ Directory&lt;/h3&gt;

&lt;p&gt;When generating the site, Hugo will create new files and update existing ones in the &lt;code&gt;public/&lt;/code&gt; directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.&lt;/p&gt;

&lt;p&gt;Note: If you&amp;rsquo;re building on an SSD, you should ignore this. Churning on a SSD can be costly.&lt;/p&gt;

&lt;h3 id=&#34;hugo-s-watch-option&#34;&gt;Hugo&amp;rsquo;s Watch Option&lt;/h3&gt;

&lt;p&gt;Hugo&amp;rsquo;s &amp;ldquo;&lt;code&gt;--watch&lt;/code&gt;&amp;rdquo; option will monitor the content/ and your theme directories for changes and rebuild the site automatically.&lt;/p&gt;

&lt;h3 id=&#34;live-reload&#34;&gt;Live Reload&lt;/h3&gt;

&lt;p&gt;Hugo&amp;rsquo;s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, &amp;ldquo;Wow, that&amp;rsquo;s totally amazing.&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;development-commands&#34;&gt;Development Commands&lt;/h3&gt;

&lt;p&gt;Use the following commands as the basis for your workflow.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## purge old files. hugo will recreate the public directory.
##
$ rm -rf public
##
## run hugo in watch mode
##
$ hugo server --watch --verbose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I&amp;rsquo;ve said this before, it&amp;rsquo;s amazing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -rf public
$ hugo server --watch --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content
0 future content
0 pages created
0 tags created
0 categories created
in 2 ms
Watching for changes in /Users/quoha/Sites/zafta/content
Serving pages from /Users/quoha/Sites/zafta/public
Web Server is available at http://localhost:1313
Press Ctrl+C to stop
INFO: 2014/09/29 File System Event: [&amp;quot;/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html&amp;quot;: MODIFY|ATTRIB]
Change detected, rebuilding site

WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content
0 future content
0 pages created
0 tags created
0 categories created
in 1 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-the-home-page-template&#34;&gt;Update the Home Page Template&lt;/h2&gt;

&lt;p&gt;The home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme&amp;rsquo;s layout/ directory:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;index.html&lt;/li&gt;
&lt;li&gt;_default/list.html&lt;/li&gt;
&lt;li&gt;_default/single.html&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We could update one of the default templates, but a good design decision is to update the most specific template available. That&amp;rsquo;s not a hard and fast rule (in fact, we&amp;rsquo;ll break it a few times in this tutorial), but it is a good generalization.&lt;/p&gt;

&lt;h3 id=&#34;make-a-static-home-page&#34;&gt;Make a Static Home Page&lt;/h3&gt;

&lt;p&gt;Right now, that page is empty because we don&amp;rsquo;t have any content and we don&amp;rsquo;t have any logic in the template. Let&amp;rsquo;s change that by adding some text to the template.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/layouts/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;p&amp;gt;hugo says hello!&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
:wq

$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build the web site and then verify the results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content
0 future content
0 pages created
0 tags created
0 categories created
in 2 ms

$ find public -type f -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff  78 Sep 29 21:26 public/index.html

$ cat public/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;p&amp;gt;hugo says hello!&amp;lt;/p&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;live-reload-1&#34;&gt;Live Reload&lt;/h4&gt;

&lt;p&gt;Note: If you&amp;rsquo;re running the server with the &lt;code&gt;--watch&lt;/code&gt; option, you&amp;rsquo;ll see different content in the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat public/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;p&amp;gt;hugo says hello!&amp;lt;/p&amp;gt;
&amp;lt;script&amp;gt;document.write(&#39;&amp;lt;script src=&amp;quot;http://&#39;
        + (location.host || &#39;localhost&#39;).split(&#39;:&#39;)[0]
    + &#39;:1313/livereload.js?mindelay=10&amp;quot;&amp;gt;&amp;lt;/&#39;
        + &#39;script&amp;gt;&#39;)&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you use &lt;code&gt;--watch&lt;/code&gt;, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.&lt;/p&gt;

&lt;h3 id=&#34;build-a-dynamic-home-page&#34;&gt;Build a &amp;ldquo;Dynamic&amp;rdquo; Home Page&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Dynamic home page?&amp;rdquo; Hugo&amp;rsquo;s a static web site generator, so this seems an odd thing to say. I mean let&amp;rsquo;s have the home page automatically reflect the content in the site every time Hugo builds it. We&amp;rsquo;ll use iteration in the template to do that.&lt;/p&gt;

&lt;h4 id=&#34;create-new-posts&#34;&gt;Create New Posts&lt;/h4&gt;

&lt;p&gt;Now that we have the home page generating static content, let&amp;rsquo;s add some content to the site. We&amp;rsquo;ll display these posts as a list on the home page and on their own page, too.&lt;/p&gt;

&lt;p&gt;Hugo has a command to generate a skeleton post, just like it does for sites and themes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo --verbose new post/first.md
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 attempting to create  post/first.md of post
INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md
ERROR: 2014/09/29 Unable to Cast &amp;lt;nil&amp;gt; to map[string]interface{}

$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That wasn&amp;rsquo;t very nice, was it?&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;new&amp;rdquo; command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there&amp;rsquo;s a theme. For me, the workaround was to create an archetypes file specifically for the post type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/archetypes/post.md
+++
Description = &amp;quot;&amp;quot;
Tags = []
Categories = []
+++
:wq

$ find themes/zafta/archetypes -type f | xargs ls -l
-rw-r--r--  1 quoha  staff   0 Sep 29 21:53 themes/zafta/archetypes/default.md
-rw-r--r--  1 quoha  staff  51 Sep 29 21:54 themes/zafta/archetypes/post.md

$ hugo --verbose new post/first.md
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 attempting to create  post/first.md of post
INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md
INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md
/Users/quoha/Sites/zafta/content/post/first.md created

$ hugo --verbose new post/second.md
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 attempting to create  post/second.md of post
INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md
INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md
/Users/quoha/Sites/zafta/content/post/second.md created

$ ls -l content/post
total 16
-rw-r--r--  1 quoha  staff  104 Sep 29 21:54 first.md
-rw-r--r--  1 quoha  staff  105 Sep 29 21:57 second.md

$ cat content/post/first.md
+++
Categories = []
Description = &amp;quot;&amp;quot;
Tags = []
date = &amp;quot;2014-09-29T21:54:53-05:00&amp;quot;
title = &amp;quot;first&amp;quot;

+++
my first post

$ cat content/post/second.md
+++
Categories = []
Description = &amp;quot;&amp;quot;
Tags = []
date = &amp;quot;2014-09-29T21:57:09-05:00&amp;quot;
title = &amp;quot;second&amp;quot;

+++
my second post

$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build the web site and then verify the results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -rf public
$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 found taxonomies: map[string]string{&amp;quot;category&amp;quot;:&amp;quot;categories&amp;quot;, &amp;quot;tag&amp;quot;:&amp;quot;tags&amp;quot;}
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content
0 future content
2 pages created
0 tags created
0 categories created
in 4 ms
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output says that it created 2 pages. Those are our new posts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find public -type f -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff  78 Sep 29 22:13 public/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:13 public/post/first/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:13 public/post/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:13 public/post/second/index.html
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new files are empty because because the templates used to generate the content are empty. The homepage doesn&amp;rsquo;t show the new content, either. We have to update the templates to add the posts.&lt;/p&gt;

&lt;h3 id=&#34;list-and-single-templates&#34;&gt;List and Single Templates&lt;/h3&gt;

&lt;p&gt;In Hugo, we have three major kinds of templates. There&amp;rsquo;s the home page template that we updated previously. It is used only by the home page. We also have &amp;ldquo;single&amp;rdquo; templates which are used to generate output for a single content file. We also have &amp;ldquo;list&amp;rdquo; templates that are used to group multiple pieces of content before generating output.&lt;/p&gt;

&lt;p&gt;Generally speaking, list templates are named &amp;ldquo;list.html&amp;rdquo; and single templates are named &amp;ldquo;single.html.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;There are three other types of templates: partials, content views, and terms. We will not go into much detail on these.&lt;/p&gt;

&lt;h3 id=&#34;add-content-to-the-homepage&#34;&gt;Add Content to the Homepage&lt;/h3&gt;

&lt;p&gt;The home page will contain a list of posts. Let&amp;rsquo;s update its template to add the posts that we just created. The logic in the template will run every time we build the site.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/layouts/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
  {{ range first 10 .Data.Pages }}
    &amp;lt;h1&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
  {{ end }}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
:wq

$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo uses the Go template engine. That engine scans the template files for commands which are enclosed between &amp;ldquo;{{&amp;rdquo; and &amp;ldquo;}}&amp;rdquo;. In our template, the commands are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;range&lt;/li&gt;
&lt;li&gt;.Title&lt;/li&gt;
&lt;li&gt;end&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &amp;ldquo;range&amp;rdquo; command is an iterator. We&amp;rsquo;re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;.Title&amp;rdquo; command prints the value of the &amp;ldquo;title&amp;rdquo; variable. Hugo pulls it from the front matter in the Markdown file.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;end&amp;rdquo; command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds &amp;ldquo;end.&amp;rdquo; Everything between the &amp;ldquo;range&amp;rdquo; and &amp;ldquo;end&amp;rdquo; is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.&lt;/p&gt;

&lt;p&gt;Build the web site and then verify the results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -rf public
$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 found taxonomies: map[string]string{&amp;quot;tag&amp;quot;:&amp;quot;tags&amp;quot;, &amp;quot;category&amp;quot;:&amp;quot;categories&amp;quot;}
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content
0 future content
2 pages created
0 tags created
0 categories created
in 4 ms
$ find public -type f -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff  94 Sep 29 22:23 public/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:23 public/post/first/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:23 public/post/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:23 public/post/second/index.html
$ cat public/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;

    &amp;lt;h1&amp;gt;second&amp;lt;/h1&amp;gt;

    &amp;lt;h1&amp;gt;first&amp;lt;/h1&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Congratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let&amp;rsquo;s take a moment to appreciate what we&amp;rsquo;ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you&amp;rsquo;ve learned everything you need to know to build a theme. All that&amp;rsquo;s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.&lt;/p&gt;

&lt;p&gt;And, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don&amp;rsquo;t worry, though, that&amp;rsquo;s all to come.&lt;/p&gt;

&lt;h3 id=&#34;add-content-to-the-posts&#34;&gt;Add Content to the Posts&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re working with posts, which are in the content/post/ directory. That means that their section is &amp;ldquo;post&amp;rdquo; (and if we don&amp;rsquo;t do something weird, their type is also &amp;ldquo;post&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Hugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can&amp;rsquo;t find one, then it will look in the _default/ directory. There are some twists that we&amp;rsquo;ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.&lt;/p&gt;

&lt;p&gt;Now that we know the search rule, let&amp;rsquo;s see what we actually have available:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find themes/zafta -name single.html | xargs ls -l
-rw-r--r--  1 quoha  staff  132 Sep 29 17:31 themes/zafta/layouts/_default/single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could create a new template, post/single.html, or change the default. Since we don&amp;rsquo;t know of any other content types, let&amp;rsquo;s start with updating the default.&lt;/p&gt;

&lt;p&gt;Remember, any content that we haven&amp;rsquo;t created a template for will end up using this template. That can be good or bad. Bad because I know that we&amp;rsquo;re going to be adding different types of content and we&amp;rsquo;re going to end up undoing some of the changes we&amp;rsquo;ve made. It&amp;rsquo;s good because we&amp;rsquo;ll be able to see immediate results. It&amp;rsquo;s also good to start here because we can start to build the basic layout for the site. As we add more content types, we&amp;rsquo;ll refactor this file and move logic around. Hugo makes that fairly painless, so we&amp;rsquo;ll accept the cost and proceed.&lt;/p&gt;

&lt;p&gt;Please see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you&amp;rsquo;re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That&amp;rsquo;s a refreshing amount of joy right there.&lt;/p&gt;

&lt;h4 id=&#34;update-the-template-file&#34;&gt;Update the Template File&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/layouts/_default/single.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;{{ .Title }}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
  {{ .Content }}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
:wq

$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build the web site and verify the results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -rf public
$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 found taxonomies: map[string]string{&amp;quot;tag&amp;quot;:&amp;quot;tags&amp;quot;, &amp;quot;category&amp;quot;:&amp;quot;categories&amp;quot;}
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content
0 future content
2 pages created
0 tags created
0 categories created
in 4 ms

$ find public -type f -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff   94 Sep 29 22:40 public/index.html
-rw-r--r--  1 quoha  staff  125 Sep 29 22:40 public/post/first/index.html
-rw-r--r--  1 quoha  staff    0 Sep 29 22:40 public/post/index.html
-rw-r--r--  1 quoha  staff  128 Sep 29 22:40 public/post/second/index.html

$ cat public/post/first/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;first&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;first&amp;lt;/h1&amp;gt;
  &amp;lt;p&amp;gt;my first post&amp;lt;/p&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

$ cat public/post/second/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;second&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;second&amp;lt;/h1&amp;gt;
  &amp;lt;p&amp;gt;my second post&amp;lt;/p&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the posts now have content. You can go to localhost:1313/post/first to verify.&lt;/p&gt;

&lt;h3 id=&#34;linking-to-content&#34;&gt;Linking to Content&lt;/h3&gt;

&lt;p&gt;The posts are on the home page. Let&amp;rsquo;s add a link from there to the post. Since this is the home page, we&amp;rsquo;ll update its template.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/layouts/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
  {{ range first 10 .Data.Pages }}
    &amp;lt;h1&amp;gt;&amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
  {{ end }}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build the web site and verify the results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -rf public
$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 found taxonomies: map[string]string{&amp;quot;tag&amp;quot;:&amp;quot;tags&amp;quot;, &amp;quot;category&amp;quot;:&amp;quot;categories&amp;quot;}
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content
0 future content
2 pages created
0 tags created
0 categories created
in 4 ms

$ find public -type f -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff  149 Sep 29 22:44 public/index.html
-rw-r--r--  1 quoha  staff  125 Sep 29 22:44 public/post/first/index.html
-rw-r--r--  1 quoha  staff    0 Sep 29 22:44 public/post/index.html
-rw-r--r--  1 quoha  staff  128 Sep 29 22:44 public/post/second/index.html

$ cat public/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;

    &amp;lt;h1&amp;gt;&amp;lt;a href=&amp;quot;/post/second/&amp;quot;&amp;gt;second&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;

    &amp;lt;h1&amp;gt;&amp;lt;a href=&amp;quot;/post/first/&amp;quot;&amp;gt;first&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-a-post-listing&#34;&gt;Create a Post Listing&lt;/h3&gt;

&lt;p&gt;We have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let&amp;rsquo;s make it show a list of all posts (not just the first ten).&lt;/p&gt;

&lt;p&gt;We need to decide which template to update. This will be a listing, so it should be a list template. Let&amp;rsquo;s take a quick look and see which list templates are available.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find themes/zafta -name list.html | xargs ls -l
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/_default/list.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with the single post, we have to decide to update _default/list.html or create post/list.html. We still don&amp;rsquo;t have multiple content types, so let&amp;rsquo;s stay consistent and update the default list template.&lt;/p&gt;

&lt;h2 id=&#34;creating-top-level-pages&#34;&gt;Creating Top Level Pages&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s add an &amp;ldquo;about&amp;rdquo; page and display it at the top level (as opposed to a sub-level like we did with posts).&lt;/p&gt;

&lt;p&gt;The default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let&amp;rsquo;s verify that by creating an &amp;ldquo;about&amp;rdquo; page at the top level:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi content/about.md
+++
title = &amp;quot;about&amp;quot;
description = &amp;quot;about this site&amp;quot;
date = &amp;quot;2014-09-27&amp;quot;
slug = &amp;quot;about time&amp;quot;
+++

## about us

i&#39;m speechless
:wq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate the web site and verify the results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find public -name &#39;*.html&#39; | xargs ls -l
-rw-rw-r--  1 mdhender  staff   334 Sep 27 15:08 public/about-time/index.html
-rw-rw-r--  1 mdhender  staff   527 Sep 27 15:08 public/index.html
-rw-rw-r--  1 mdhender  staff   358 Sep 27 15:08 public/post/first-post/index.html
-rw-rw-r--  1 mdhender  staff     0 Sep 27 15:08 public/post/index.html
-rw-rw-r--  1 mdhender  staff   342 Sep 27 15:08 public/post/second-post/index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the page wasn&amp;rsquo;t created at the top level. It was created in a sub-directory named &amp;lsquo;about-time/&amp;rsquo;. That name came from our slug. Hugo will use the slug to name the generated content. It&amp;rsquo;s a reasonable default, by the way, but we can learn a few things by fighting it for this file.&lt;/p&gt;

&lt;p&gt;One other thing. Take a look at the home page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat public/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;&amp;lt;a href=&amp;quot;http://localhost:1313/post/theme/&amp;quot;&amp;gt;creating a new theme&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
    &amp;lt;h1&amp;gt;&amp;lt;a href=&amp;quot;http://localhost:1313/about-time/&amp;quot;&amp;gt;about&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
    &amp;lt;h1&amp;gt;&amp;lt;a href=&amp;quot;http://localhost:1313/post/second-post/&amp;quot;&amp;gt;second&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
    &amp;lt;h1&amp;gt;&amp;lt;a href=&amp;quot;http://localhost:1313/post/first-post/&amp;quot;&amp;gt;first&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
&amp;lt;script&amp;gt;document.write(&#39;&amp;lt;script src=&amp;quot;http://&#39;
        + (location.host || &#39;localhost&#39;).split(&#39;:&#39;)[0]
        + &#39;:1313/livereload.js?mindelay=10&amp;quot;&amp;gt;&amp;lt;/&#39;
        + &#39;script&amp;gt;&#39;)&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the &amp;ldquo;about&amp;rdquo; link is listed with the posts? That&amp;rsquo;s not desirable, so let&amp;rsquo;s change that first.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/layouts/index.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;posts&amp;lt;/h1&amp;gt;
  {{ range first 10 .Data.Pages }}
    {{ if eq .Type &amp;quot;post&amp;quot;}}
      &amp;lt;h2&amp;gt;&amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;
    {{ end }}
  {{ end }}

  &amp;lt;h1&amp;gt;pages&amp;lt;/h1&amp;gt;
  {{ range .Data.Pages }}
    {{ if eq .Type &amp;quot;page&amp;quot; }}
      &amp;lt;h2&amp;gt;&amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;
    {{ end }}
  {{ end }}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
:wq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.&lt;/p&gt;

&lt;p&gt;But, that about page still renders to about-time/index.html.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find public -name &#39;*.html&#39; | xargs ls -l
-rw-rw-r--  1 mdhender  staff    334 Sep 27 15:33 public/about-time/index.html
-rw-rw-r--  1 mdhender  staff    645 Sep 27 15:33 public/index.html
-rw-rw-r--  1 mdhender  staff    358 Sep 27 15:33 public/post/first-post/index.html
-rw-rw-r--  1 mdhender  staff      0 Sep 27 15:33 public/post/index.html
-rw-rw-r--  1 mdhender  staff    342 Sep 27 15:33 public/post/second-post/index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Knowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let&amp;rsquo;s do it the hard way and change the permalink in the configuration file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi config.toml
[permalinks]
    page = &amp;quot;/:title/&amp;quot;
    about = &amp;quot;/:filename/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate the web site and verify that this didn&amp;rsquo;t work. Hugo lets &amp;ldquo;slug&amp;rdquo; or &amp;ldquo;URL&amp;rdquo; override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.&lt;/p&gt;

&lt;h2 id=&#34;sharing-templates&#34;&gt;Sharing Templates&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;ve been following along, you probably noticed that posts have titles in the browser and the home page doesn&amp;rsquo;t. That&amp;rsquo;s because we didn&amp;rsquo;t put the title in the home page&amp;rsquo;s template (layouts/index.html). That&amp;rsquo;s an easy thing to do, but let&amp;rsquo;s look at a different option.&lt;/p&gt;

&lt;p&gt;We can put the common bits into a shared template that&amp;rsquo;s stored in the themes/zafta/layouts/partials/ directory.&lt;/p&gt;

&lt;h3 id=&#34;create-the-header-and-footer-partials&#34;&gt;Create the Header and Footer Partials&lt;/h3&gt;

&lt;p&gt;In Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme&amp;rsquo;s presentation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/layouts/partials/header.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;{{ .Title }}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
:wq

$ vi themes/zafta/layouts/partials/footer.html
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
:wq
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;update-the-home-page-template-to-use-the-partials&#34;&gt;Update the Home Page Template to Use the Partials&lt;/h3&gt;

&lt;p&gt;The most noticeable difference between a template call and a partials call is the lack of path:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ template &amp;quot;theme/partials/header.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;versus&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ partial &amp;quot;header.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both pass in the context.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s change the home page template to use these new partials.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/layouts/index.html
{{ partial &amp;quot;header.html&amp;quot; . }}

  &amp;lt;h1&amp;gt;posts&amp;lt;/h1&amp;gt;
  {{ range first 10 .Data.Pages }}
    {{ if eq .Type &amp;quot;post&amp;quot;}}
      &amp;lt;h2&amp;gt;&amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;
    {{ end }}
  {{ end }}

  &amp;lt;h1&amp;gt;pages&amp;lt;/h1&amp;gt;
  {{ range .Data.Pages }}
    {{ if or (eq .Type &amp;quot;page&amp;quot;) (eq .Type &amp;quot;about&amp;quot;) }}
      &amp;lt;h2&amp;gt;&amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;
    {{ end }}
  {{ end }}

{{ partial &amp;quot;footer.html&amp;quot; . }}
:wq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate the web site and verify the results. The title on the home page is now &amp;ldquo;your title here&amp;rdquo;, which comes from the &amp;ldquo;title&amp;rdquo; variable in the config.toml file.&lt;/p&gt;

&lt;h3 id=&#34;update-the-default-single-template-to-use-the-partials&#34;&gt;Update the Default Single Template to Use the Partials&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/layouts/_default/single.html
{{ partial &amp;quot;header.html&amp;quot; . }}

  &amp;lt;h1&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
  {{ .Content }}

{{ partial &amp;quot;footer.html&amp;quot; . }}
:wq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.&lt;/p&gt;

&lt;h2 id=&#34;add-date-published-to-posts&#34;&gt;Add “Date Published” to Posts&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s common to have posts display the date that they were written or published, so let&amp;rsquo;s add that. The front matter of our posts has a variable named &amp;ldquo;date.&amp;rdquo; It&amp;rsquo;s usually the date the content was created, but let&amp;rsquo;s pretend that&amp;rsquo;s the value we want to display.&lt;/p&gt;

&lt;h3 id=&#34;add-date-published-to-the-template&#34;&gt;Add “Date Published” to the Template&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll start by updating the template used to render the posts. The template code will look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Date.Format &amp;quot;Mon, Jan 2, 2006&amp;quot; }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Posts use the default single template, so we&amp;rsquo;ll change that file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/layouts/_default/single.html
{{ partial &amp;quot;header.html&amp;quot; . }}

  &amp;lt;h1&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
  &amp;lt;h2&amp;gt;{{ .Date.Format &amp;quot;Mon, Jan 2, 2006&amp;quot; }}&amp;lt;/h2&amp;gt;
  {{ .Content }}

{{ partial &amp;quot;footer.html&amp;quot; . }}
:wq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate the web site and verify the results. The posts now have the date displayed in them. There&amp;rsquo;s a problem, though. The &amp;ldquo;about&amp;rdquo; page also has the date displayed.&lt;/p&gt;

&lt;p&gt;As usual, there are a couple of ways to make the date display only on posts. We could do an &amp;ldquo;if&amp;rdquo; statement like we did on the home page. Another way would be to create a separate template for posts.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;if&amp;rdquo; solution works for sites that have just a couple of content types. It aligns with the principle of &amp;ldquo;code for today,&amp;rdquo; too.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume, though, that we&amp;rsquo;ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we&amp;rsquo;re going to create a section template.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s restore the default single template before we forget.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir themes/zafta/layouts/post
$ vi themes/zafta/layouts/_default/single.html
{{ partial &amp;quot;header.html&amp;quot; . }}

  &amp;lt;h1&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
  {{ .Content }}

{{ partial &amp;quot;footer.html&amp;quot; . }}
:wq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ll update the post&amp;rsquo;s version of the single template. If you remember Hugo&amp;rsquo;s rules, the template engine will use this version over the default.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi themes/zafta/layouts/post/single.html
{{ partial &amp;quot;header.html&amp;quot; . }}

  &amp;lt;h1&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
  &amp;lt;h2&amp;gt;{{ .Date.Format &amp;quot;Mon, Jan 2, 2006&amp;quot; }}&amp;lt;/h2&amp;gt;
  {{ .Content }}

{{ partial &amp;quot;footer.html&amp;quot; . }}
:wq

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn&amp;rsquo;t.&lt;/p&gt;

&lt;h3 id=&#34;don-t-repeat-yourself&#34;&gt;Don&amp;rsquo;t Repeat Yourself&lt;/h3&gt;

&lt;p&gt;DRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you&amp;rsquo;re figuring that out, accept that you&amp;rsquo;ll be doing some refactoring. Hugo makes that easy and fast, so it&amp;rsquo;s okay to delay splitting up a template.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Argument checking for native addons for Node.js. Do it right!</title>
      <link>https://example.com/how-to-convert-args-from-js-to-cpp/</link>
      <pubDate>Thu, 11 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/how-to-convert-args-from-js-to-cpp/</guid>
      <description>

&lt;div class=&#34;featured-image&#34;&gt;
![NanCheck](logo.jpg)
&lt;/div&gt;

&lt;p&gt;During development of &lt;a href=&#34;https://cloudcv.io&#34;&gt;CloudCV&lt;/a&gt; I came to the problem on converting &lt;code&gt;v8::Arguments&lt;/code&gt; to
native C++ data types in my Node.js native module. If you are new to C++ and Node.js, I suggest you to read how to write C++ modules for Node.js and connecting OpenCV and Node.js first.&lt;/p&gt;

&lt;p&gt;Mapping V8 data types to native C++ equivalents is trivial, but somewhat wordy. One should take the
argument at given index, check whether it is defined, then check it&amp;rsquo;s type and finally cast to C++ type.
This works fine while you have function that receive two or three arguments of trivial type (That can be mapped directly to built-in C++ types). What about strings? Arrays? Complex types like objects or function callback?
You code will grow like and became hard-to-maintain pasta-code some day.&lt;/p&gt;

&lt;p&gt;In this post I present my approach on solving this problem with a laconic way on describing what do you expect as input arguments.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;
&lt;div class=&#34;clearfix&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;To illustrate the difference between imperative approach I included source code for calibrationPatternDetect method that expose function to detect calibration pattern on a single image to Node.js code. As you may see below, there are a lot of &lt;em&gt;if&lt;/em&gt; conditions, magic numbers and no type checking for a half of arguments. But even without it, this function occupy 50 lines of code.
What even worse, 90% of this code is going to be the same for other functions. The main purpose of code of any &lt;code&gt;NAN_METHOD&lt;/code&gt; implementation - to marshal data in such a way it can be used by C++ code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;NAN_METHOD(calibrationPatternDetect)
{
    NanScope();

    if (args.Length() != 5)
    {
        return NanThrowError(&amp;quot;Invalid number of arguments&amp;quot;);  
    }

    if (!args[0]-&amp;gt;IsObject())
    {
        return NanThrowTypeError(&amp;quot;First argument should be a Buffer&amp;quot;);      
    }

    // 0 - image
    // 1 - width
    // 2 - height
    // 3 - pattern
    // 4 - callback

    int w  = args[1]-&amp;gt;Uint32Value();
    int h  = args[2]-&amp;gt;Uint32Value();
    int pt = args[3]-&amp;gt;Uint32Value();
    PatternType pattern;

    switch (pt)
    {
        case 0:
            pattern = CHESSBOARD;
            break;

        case 1:
            pattern = CIRCLES_GRID;
            break;

        case 2:
            pattern = ASYMMETRIC_CIRCLES_GRID;
            break;    

        default:
            return NanThrowError(&amp;quot;Unsupported pattern type. Only 0 (CHESSBOARD), 1 (CIRCLES_GRID) or 2 (ASYMMETRIC_CIRCLES_GRID) are supported.&amp;quot;);
    };

    if (!args[4]-&amp;gt;IsFunction())
    {
        return NanThrowTypeError(&amp;quot;Last argument must be a function.&amp;quot;);
    }

    // The task holds our custom status information for this asynchronous call,
    // like the callback function we want to call when returning to the main
    // thread and the status information.

    NanCallback *callback = new NanCallback(args[4].As&amp;lt;Function&amp;gt;());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the goal is to add more syntax sugar for argument checking.
Basically, it should provide a convenient way to check number and type of arguments passed.
For &lt;a href=&#34;https://cloudcv.io&#34;&gt;CloudCV&lt;/a&gt; project I&amp;rsquo;ve ended with a declarative approach because I found it fit my needs very much
and makes argument checking self-explanatory. Here is how new implementation of &lt;code&gt;calibrationPatternDetect&lt;/code&gt; looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;NAN_METHOD(calibrationPatternDetect)
{
    NanScope();

    Local&amp;lt;Object&amp;gt;   imageBuffer;
    Local&amp;lt;Function&amp;gt; callback;
    cv::Size        patternSize;
    PatternType     pattern;

    try
    {
        if (NanCheck(args).ArgumentsCount(5)
            .Argument(0).IsBuffer().Bind(imageBuffer)
            .Argument(1).Bind(patternSize.width)
            .Argument(2).Bind(patternSize.height)
            .Argument(3).StringEnum&amp;lt;PatternType&amp;gt;({ 
                { &amp;quot;CHESSBOARD&amp;quot;,     PatternType::CHESSBOARD }, 
                { &amp;quot;CIRCLES_GRID&amp;quot;,   PatternType::CIRCLES_GRID }, 
                { &amp;quot;ACIRCLES_GRID&amp;quot;,  PatternType::ACIRCLES_GRID } }).Bind(pattern)
            .Argument(4).IsFunction().Bind(callback))
        {
            NanCallback *nanCallback = new NanCallback(callback);
            NanAsyncQueueWorker(new DetectPatternTask(imageBuffer, patternSize, pattern, nanCallback));
            NanReturnValue(NanTrue());
        }

        NanReturnValue(NanFalse());
    }
    catch (ArgumentMismatchException exc)
    {
        return NanThrowTypeError(exc.what());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I hope you agree that second version is much more easy to read. Fluent architecture allows to write predicates in a chain, which actually is very similar to the way we thing. All predicate has self-telling names made from verb and a noun. So let me give you a brief overview what &lt;code&gt;NanCheck&lt;/code&gt; is capable of.&lt;/p&gt;

&lt;h2 id=&#34;fluent-api&#34;&gt;Fluent API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Method_chaining&#34;&gt;Method chaining&lt;/a&gt; (aka Fluent API) makes it very easy to build final predicate for argument checking via consecutive checks.
Each next step will be made &lt;strong&gt;if and only if&lt;/strong&gt; all previous predicates were successful.
In case of error, predicate will throw an &lt;code&gt;ArgumentMismatchException&lt;/code&gt; exception that will terminate all further checks. &lt;code&gt;NanCheck(args)&lt;/code&gt; can be evaluated to &lt;code&gt;bool&lt;/code&gt; which makes it possible to use NanCheck in a condition statement:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (NanCheck(args). ...) {
    // This code will be executed if argument parsing
    // will be successful        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;type-checking&#34;&gt;Type checking&lt;/h2&gt;

&lt;p&gt;To check particular argument at given index, &lt;code&gt;NanCheckArguments&lt;/code&gt; provide a &lt;code&gt;Argument(index)&lt;/code&gt; function. This function lets you to build a sub-predicate for given argument and bind it&amp;rsquo;s value with particular local variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    if (NanCheck(args).Argument(0).IsBuffer()) {
        // This code will be executed if argument parsing
        // will be successful        
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Currently, &lt;code&gt;NanCheck&lt;/code&gt; support type checking of the following built-in V8 types:
1. &lt;code&gt;v8::Function&lt;/code&gt;
2. &lt;code&gt;v8::Object&lt;/code&gt;
3. &lt;code&gt;v8::String&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In addition, it offers &lt;code&gt;NotNull&lt;/code&gt; predicate to ensure argument is not null or empty.
The list of predicates will grow for sure. New functions to check whether argument is &lt;code&gt;v8::Array&lt;/code&gt;, &lt;code&gt;v8::Number&lt;/code&gt;, &lt;code&gt;v8::Integer&lt;/code&gt;, &lt;code&gt;v8::Boolean&lt;/code&gt; will be added in a next updates.&lt;/p&gt;

&lt;h2 id=&#34;binding&#34;&gt;Binding&lt;/h2&gt;

&lt;p&gt;After type checking, it&amp;rsquo;s necessary to complete sub-predicate construction by &lt;em&gt;binding&lt;/em&gt; argument to a local variable. Binding is a assignment of the argument (with data marshaling, if it&amp;rsquo;s necessary) to a variable that will be used later;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    Local&amp;lt;Object&amp;gt;   imageBuffer;
    if (NanCheck(args).Argument(0).IsBuffer().Bind(imageBuffer)) {
        // This code will be executed if argument parsing
        // will be successful        
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NanCheck support transparent binding to all v8 types (Number, String, Function, Object, Array, etc.), native C++ and OpenCV types (via &lt;a href=&#34;https://github.com/BloodAxe/CloudCVBackend/blob/master/src/framework/marshal/opencv.cpp&#34;&gt;marshaling system&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    cv::Size        patternSize;
    if (NanCheck(args).Argument(1).IsObject().Bind(patternSize)) {
        // This code will be executed if argument parsing
        // will be successful        
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a special case of string arguments called &lt;code&gt;StringEnum&lt;/code&gt; - that is, a string argument, which can be one of a priory defined values. It introduced to support *&lt;em&gt;C++ enum&lt;/em&gt; types and pass them
as string constants. &lt;code&gt;StringEnum&lt;/code&gt; predicate allow to parse string value and map to C++ enum type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    PatternType     pattern;
    if (NanCheck(args)
        .Argument(3).StringEnum&amp;lt;PatternType&amp;gt;({ 
            { &amp;quot;CHESSBOARD&amp;quot;,     PatternType::CHESSBOARD }, 
            { &amp;quot;CIRCLES_GRID&amp;quot;,   PatternType::CIRCLES_GRID }, 
            { &amp;quot;ACIRCLES_GRID&amp;quot;,  PatternType::ACIRCLES_GRID } }).Bind(pattern)) {
        // This code will be executed if argument parsing
        // will be successful        
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implementation-highlights&#34;&gt;Implementation highlights&lt;/h2&gt;

&lt;p&gt;Thanks to C++11, it&amp;rsquo;s really easy to construct predicate chain using lambda functions. Basically predicate chain is nothing but a recursive anonymous function of the following form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    auto initFn = [innerPredicate, outerPredicate](const v8::Arguments&amp;amp; args) {
        return innerPredicate(args) &amp;amp;&amp;amp; outerPredicate(args);
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To illustrate an idea of building predicate chain, let&amp;rsquo;s take a look on ArgumentsCount implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    NanCheckArguments&amp;amp; NanCheckArguments::ArgumentsCount(int count)
    {
        return AddAndClause([count](const v8::Arguments&amp;amp; args) 
        { 
            if (args.Length() != count)
                throw ArgumentMismatchException(args.Length(), count); 

            return true;
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we construct outer predicate which compare number of arguments to expected value
and throw an exception if it does not match.&lt;/p&gt;

&lt;p&gt;With a help of &lt;code&gt;std::initializer_list&lt;/code&gt; it became really simple to declare string enum with minimal syntax overhead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    class NanMethodArgBinding
    {
    public:
    ...
        template &amp;lt;typename T&amp;gt;
        NanArgStringEnum&amp;lt;T&amp;gt; 
        StringEnum(std::initializer_list&amp;lt; std::pair&amp;lt;const char*, T&amp;gt; &amp;gt; possibleValues);
    ...
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re able to call this function with arbitrary number of elements for this enum using
&lt;code&gt;std::initializer_list&lt;/code&gt; syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    { 
        { &amp;quot;CHESSBOARD&amp;quot;,     PatternType::CHESSBOARD }, 
        { &amp;quot;CIRCLES_GRID&amp;quot;,   PatternType::CIRCLES_GRID }, 
        { &amp;quot;ACIRCLES_GRID&amp;quot;,  PatternType::ACIRCLES_GRID }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/BloodAxe/CloudCVBackend/blob/master/src/framework/NanCheck.hpp&#34;&gt;&lt;strong&gt;NanCheck&lt;/strong&gt;&lt;/a&gt; helped me to reduce amount of code required to check arguments passed to &lt;a href=&#34;https://cloudcv.io&#34;&gt;CloudCV&lt;/a&gt; back-end. There are many cool ideas that I&amp;rsquo;ll probably add as soon as there will be necessity to have them in my library:
- Strongly typed objects (Objects with required fields)
- Optional parameters with default values
- Automatic type inference based on &lt;code&gt;Bind&amp;lt;T&amp;gt;(...)&lt;/code&gt; type.
- Support of multiple types per argument (Parameter can be either of type A or B)&lt;/p&gt;

&lt;p&gt;Please leave your comments on this post. I&amp;rsquo;ve spent many hours on figuring out how to implement data marshaling and type checking in V8 and Node.js, so please help information to
spread out - share and re-tweet this post. Cheers!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computer Vision Digest - August 2014</title>
      <link>https://example.com/computer-vision-digest-august-2014/</link>
      <pubDate>Sat, 30 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/computer-vision-digest-august-2014/</guid>
      <description>

&lt;p&gt;Third &lt;a href=&#34;https://example.com/tags/digest.html&#34;&gt;computer vision digest&lt;/a&gt;. Your monthly portion of news in computer vision for August 2014.&lt;/p&gt;

&lt;p&gt;In this issue:
 - &lt;a href=&#34;#1&#34;&gt;Free Photo Editing Software Lets You Manipulate Objects in 3D&lt;/a&gt;
 - &lt;a href=&#34;#2&#34;&gt;Real-Time Digital Makeup with Projection Mapping&lt;/a&gt;
 - &lt;a href=&#34;#3&#34;&gt;Video stabilization through 3D scene recovery&lt;/a&gt;
 - &lt;a href=&#34;#4&#34;&gt;Using OpenCV, Python and Template Matching to play “Where’s Waldo?”&lt;/a&gt;
 - &lt;a href=&#34;#5&#34;&gt;OpenCV 3.0 alpha is out&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Previous issues:
 - &lt;a href=&#34;https://example.com/articles/2014-05-computer-vision-digest/&#34;&gt;Computer Vision Digest (May 2014)&lt;/a&gt;
 - &lt;a href=&#34;https://example.com/articles/2014-06-computer-vision-digest/&#34;&gt;Computer Vision Digest (June 2014)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
Feel free to leave your suggestions on interesting materials in post comments 
or via Twitter by mentioning [@cvtalks](https://twitter.com/cvtalks). 
Best links will be included into next digest!
&lt;/div&gt;

&lt;p&gt;&lt;span class=&#34;more clearfix&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;free-photo-editing-software-lets-you-manipulate-objects-in-3d&#34;&gt;Free Photo Editing Software Lets You Manipulate Objects in 3D&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://i.kinja-img.com/gawker-media/image/upload/s--CtQ_vCt9--/c_fit,fl_progressive,q_80,w_636/sbuewdyltzbjdmfjvgof.gif&#34; alt=&#34;Free Photo Editing Software Lets You Manipulate Objects in 3D&#34; /&gt;&lt;/p&gt;

&lt;p&gt;How much Photoshop magic can you make with 2D photo? This software can do more! SIGGRAPH 2014 showed us a method that enables users to perform the full range of 3D manipulations, including scaling, rotation, translation, and nonrigid deformations, to an object in a photograph. Despite the fact it has limitations to use of stock 3D models set that are available for manipulation, it is great demonstration on how 2D and 3D can be combined together to bring image manipulation for the next level. I think Adobe is already buying these guys (and one girl).&lt;/p&gt;

&lt;p&gt;The cool news, there are free demo, source code and publication paper that you can read:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cmu.edu/~om3d/sourcecodeversions.html&#34;&gt;Source code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cmu.edu/~om3d/agreement.html&#34;&gt;OS X (Mavericks) Executable Code and Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cmu.edu/~om3d/papers/SIGGRAPH2014.pdf&#34;&gt;Publication paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;real-time-digital-makeup-with-projection-mapping&#34;&gt;Real-Time Digital Makeup with Projection Mapping&lt;/h2&gt;

&lt;p&gt;This is how state of the art technologies comes to real life. Well studied algorithms and a bit of tech = amazing results. Projection mapping in conjunction with real-time face tracking made possible a virtual make-up! No more words. Watch this:&lt;/p&gt;

&lt;iframe src=&#34;//player.vimeo.com/video/103425574?byline=0&amp;amp;portrait=0&amp;amp;badge=0&amp;amp;color=cfcaca&#34; width=&#34;853&#34; height=&#34;480&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt; 

&lt;p&gt;A true beauty of augmented reality. Girls, you don&amp;rsquo;t need to do a make-up for virtual date anymore :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So how did they made it?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I assume this involves real-time frame tracker that outputs a face 3D model which is 99% tuned for particular person via offline training (Google: Active appearance model).
Have you noticed white dots on her face? These are special markers that are used to &amp;ldquo;wire&amp;rdquo; face 3D model to real one.&lt;/p&gt;

&lt;p&gt;And then they take virtual makeup (A texture that mapped onto 3D face model) and deform it to match tracked model. A projector then maps virtual makeup onto actor.&lt;/p&gt;

&lt;p&gt;Well done, OMOTE. This was great demonstration!&lt;/p&gt;

&lt;p&gt;Source: &lt;a href=&#34;http://www.augmentedrealitytrends.com/augmented-reality/projection-mapping.html&#34;&gt;Real-Time Digital Makeup with Projection Mapping&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a name=&#34;3&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hyperlapse-video-stabilization-through-3d-scene-recovery&#34;&gt;Hyperlapse video stabilization through 3D scene recovery&lt;/h2&gt;

&lt;p&gt;This is not about Instagram :)&lt;/p&gt;

&lt;p&gt;Microsoft Research showed more sophisticated video stabilization algorithms for making Hyperlapse video from the raw footage made with ordinary handheld camera.&lt;/p&gt;

&lt;iframe width=&#34;853&#34; height=&#34;480&#34; src=&#34;//www.youtube.com/embed/SOpwHaQnRSY?rel=0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Developers claim that their result impossible to achieve using alternative ways of stabilization. The method is based on the reconstruction of the 3D-scene, and then algorithm optimize &amp;ldquo;movement&amp;rdquo; of the camera along the route in order to avoid vibration, and combines the images pixel by pixel to smooth video sequence.&lt;/p&gt;

&lt;p&gt;For example, the figure below shows this route (in black) and an optimized route, which is generated by the application to render the video (red).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;microsoft-hyperlapse-path-planning.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The result is a so-called hyperlapse-video (named by analogy with the time-lapse, slow-motion filming).&lt;/p&gt;

&lt;iframe width=&#34;853&#34; height=&#34;480&#34; src=&#34;//www.youtube.com/embed/sA4Za3Hv6ng?rel=0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Technicaly, the algorithm builds Hyperlapse video in three steps:
 1. &lt;strong&gt;Recover 3D scene&lt;/strong&gt; from the camera motion. This is well-known task called &amp;ldquo;Structure from Motion&amp;rdquo; and one camera is enough to recover 3D environment (Google: Monocular SLAM).
 2. &lt;strong&gt;Optimize route&lt;/strong&gt; (or Path Planning) - on previous step algorithm recover camera route that include shakes, vibration and occasion motions that should be exludede from result Hyperlapse. The goal of this step is to make smooth and stable transition from frame to frame by optimizing route.
 3. ** Render Hyperlapse**. This step doing reverse things - it sample pixel values from all visible frames that were used to reconstruct given pose and pick best ones that produce really nice stiched image. Having 3D environment has a great advantage when algorithm has to &amp;ldquo;inpaint&amp;rdquo; missing reginos - it can sample pixels from the other frames because system reallly knows what is the 3D structure around.&lt;/p&gt;

&lt;p&gt;You can read publication of this approach from the Microsoft Research: &lt;a href=&#34;http://research.microsoft.com/en-us/um/redmond/projects/hyperlapse/paper/hyperlapse.pdf&#34;&gt;First-person Hyper-lapse Videos&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a name=&#34;4&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;using-opencv-python-and-template-matching-to-play-where-s-waldo&#34;&gt;Using OpenCV, Python and Template Matching to play “Where’s Waldo?”&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;puzzle_small.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This &lt;a href=&#34;http://machinelearningmastery.com/using-opencv-python-and-template-matching-to-play-wheres-waldo/&#34;&gt;article&lt;/a&gt; is for beginners who start learning computer vision. This tutorial describe very basic, but still powerful technique called template matching for object detection. “Where’s Waldo?” probably the best candidate for template matching demonstration - the task is very clear and this article contain step by step solution on detecting Waldo using computer vision.&lt;/p&gt;

&lt;p&gt;Using Python it&amp;rsquo;s really simple to write your first algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;puzzle = cv2.imread(args[&amp;quot;puzzle&amp;quot;])
waldo = cv2.imread(args[&amp;quot;waldo&amp;quot;])
result = cv2.matchTemplate(puzzle, waldo, cv2.TM_CCOEFF)
(_, _, minLoc, maxLoc) = cv2.minMaxLoc(result)
# the puzzle image
topLeft = maxLoc
botRight = (topLeft[0] + waldoWidth, topLeft[1] + waldoHeight)
roi = puzzle[topLeft[1]:botRight[1], topLeft[0]:botRight[0]]

# construct a darkened transparent &#39;layer&#39; to darken everything
# in the puzzle except for waldo
mask = np.zeros(puzzle.shape, dtype = &amp;quot;uint8&amp;quot;)
puzzle = cv2.addWeighted(puzzle, 0.25, mask, 0.75, 0)

# put the original waldo back in the image so that he is
# &#39;brighter&#39; than the rest of the image
puzzle[topLeft[1]:botRight[1], topLeft[0]:botRight[0]] = roi

# display the images
cv2.imshow(&amp;quot;Puzzle&amp;quot;, imutils.resize(puzzle, height = 650))
cv2.imshow(&amp;quot;Waldo&amp;quot;, waldo)
cv2.waitKey(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;puzzle_found_waldo1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Original article can be found here: &lt;a href=&#34;http://machinelearningmastery.com/using-opencv-python-and-template-matching-to-play-wheres-waldo/&#34;&gt;Using OpenCV, Python and Template Matching to play “Where’s Waldo?”&lt;/a&gt;.
&lt;hr /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;5&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;opencv-3-0-alpha-is-out&#34;&gt;OpenCV 3.0 alpha is out&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;s it. OpenCV grows and going to college. 5 years has passed since OpenCV 2.0, which brought us a new C++ API, GPU-accelerated algorithms, iOS and Android platforms support, CUDA and OpenCL, Python and Java bindings.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Modular project architecture&lt;/strong&gt;. Since very beginning OpenCV was one solid project, built and shipped as a whole, and that was good strategy for many years. However, with constantly growing functionality, including bleeding-edge algorithms published a few minutes before a pull request has been submitted to our repository, and increasing number of contributors (thank you all very much, guys!) we came to the same conclusion and decision as many other big project – the solid model does not work anymore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;T-API&lt;/strong&gt;. GPU acceleration made really easy with brand new T-API (“transparent API”) made in cooperation with Intel and AMD. &lt;a href=&#34;https://github.com/Itseez/opencv/tree/master/samples/tapi&#34;&gt;T-API Samples&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OpenCV now linked with IPP by default&lt;/strong&gt;. Intel corporation gave OpenCV another exciting present. A subset of Intel Integrated Performance Primitives (IPP) is linked by default into OpenCV and is available at &lt;strong&gt;no charge for all our users&lt;/strong&gt;. And that includes the license to redistribute applications that use IPP-accelerated OpenCV. As you may see, for quite a few image processing functions we achieved very noticeable speedup with IPP (where IPP is compared with OpenCV built with all possible optimizations turned on):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ocv3_ipp_speedup.jpg&#34; alt=&#34;IPP in OpenCV 3.0&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Last but not least, OpenCV 3.0 brings a lot of &lt;strong&gt;new functionality&lt;/strong&gt;, such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Text detection and recognition by Lluis Gomez and Stefano Fabri&lt;/li&gt;
&lt;li&gt;HDR by Fedor Morozov and Alexander Shishkov&lt;/li&gt;
&lt;li&gt;KAZE/A-KAZE by Eugene Khvedchenya, the algorithm author Pablo Alcantarilla and some improvements by F. Morozov.&lt;/li&gt;
&lt;li&gt;Smart segmentation and edge-aware filters by Vitaly Lyudvichenko, Yuri Gitman, Alexander Shishkov and Alexander Mordvintsev&lt;/li&gt;
&lt;li&gt;Car detection using Waldboost, ACF by Vlad Shakhuro and Nikita Manovich&lt;/li&gt;
&lt;li&gt;TLD tracker and several common-use optimization algorithms by Alex Leontiev&lt;/li&gt;
&lt;li&gt;Matlab bindings by Hilton Bristow, with support from Mathworks.&lt;/li&gt;
&lt;li&gt;Greatly extended Python bindings, including Python 3 support, and several OpenCV+Python tutorials by Alexander Mordvintsev, Abid Rahman and others.&lt;/li&gt;
&lt;li&gt;3D Visualization using VTK by Ozan Tonkal and Anatoly Baksheev.&lt;/li&gt;
&lt;li&gt;RGBD module by Vincent Rabaud&lt;/li&gt;
&lt;li&gt;Line Segment Detector by Daniel Angelov&lt;/li&gt;
&lt;li&gt;Many useful Computational Photography algorithms by Siddharth Kherada&lt;/li&gt;
&lt;li&gt;Shape descriptors, matching and morphing shapes (shape module) by Juan Manuel Perez Rua and Ilya Lysenkov&lt;/li&gt;
&lt;li&gt;Long-term tracking + saliency-based improvements (tracking module) by Antonella Cascitelli and Francesco Puja&lt;/li&gt;
&lt;li&gt;Another good pose estimation algorithm and the tutorial on pose estimation by Edgar Riba and Alexander Shishkov&lt;/li&gt;
&lt;li&gt;Line descriptors and matchers by Biagio Montesano and Manuele Tamburanno&lt;/li&gt;
&lt;li&gt;Myriads of improvements in various parts of the library by Steven Puttemans; thank you a lot, Steven!&lt;/li&gt;
&lt;li&gt;Several NEON optimizations by Adrian Stratulat, Cody Rigney, Alexander Petrikov, Yury Gorbachev and others.&lt;/li&gt;
&lt;li&gt;Fast foreach loop over cv::Mat by Kazuki Matsuda&lt;/li&gt;
&lt;li&gt;Image alignment (ECC algorithm) by Georgios Evangelidis&lt;/li&gt;
&lt;li&gt;GDAL image support by Marvin Smith&lt;/li&gt;
&lt;li&gt;RGBD module by Vincent Rabaud&lt;/li&gt;
&lt;li&gt;Fisheye camera model by Ilya Krylov&lt;/li&gt;
&lt;li&gt;OSX framework build script by Eugene Khvedchenya&lt;/li&gt;
&lt;li&gt;Multiple FLANN improvements by Pierre-Emmanuel Viel&lt;/li&gt;
&lt;li&gt;Improved WinRT support by Gregory Morse&lt;/li&gt;
&lt;li&gt;Latent SVM Cascade by Evgeniy Kozhinov and NNSU team (awaiting integration)&lt;/li&gt;
&lt;li&gt;Logistic regression by Rahul Kavi&lt;/li&gt;
&lt;li&gt;Five-point pose estimation algorithm by Bo Li&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The 3.0-alpha package can be downloaded:
 - &lt;a href=&#34;https://github.com/Itseez/opencv/tree/3.0.0-alpha&#34;&gt;Source code as .zip package directly from github&lt;/a&gt;
 - &lt;a href=&#34;https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.0.0-alpha/&#34;&gt;Precompiled, Windows&lt;/a&gt;
 - &lt;a href=&#34;https://sourceforge.net/projects/opencvlibrary/files/opencv-ios/3.0.0-alpha/&#34;&gt;Precompiled, iOS&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mapping data from Eigen to OpenCV and back</title>
      <link>https://example.com/mapping-eigen-to-opencv/</link>
      <pubDate>Sat, 16 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/mapping-eigen-to-opencv/</guid>
      <description>

&lt;div class=&#34;featured-image&#34;&gt;
![Eigen2CV](eigen2cv.png)
&lt;/div&gt;

&lt;p&gt;Eigen is a C++ template library for matrix and vector operations.
It is highly optimized for numeric operations and support vectorization and
use aligned memory allocators.&lt;/p&gt;

&lt;p&gt;When it comes to matrix operations, Eigen is much faster than OpenCV.
However, it can be situations when it is necessary to pass Eigen data
to OpenCV functions.&lt;/p&gt;

&lt;p&gt;In this post I will show how to map Eigen data to OpenCV with easy and efficient
way. No copy, minimal overhead and maximum syntax sugar:
&lt;div class=&#34;clearfix&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Simple case&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Eigen::ArrayXXd img(480, 640);
...
cv::imshow(&amp;quot;test&amp;quot;, eigen2cv(img));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Proposed approach does not limited to continuous memory layout - it support expression and blocks
as well. If given expression has to be evaluated - it will be evaluated into temporary dense storage
and then mapped to OpenCV structure:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Expressions&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Unsharp mask
Eigen::ArrayXXd img, blur;    
cv::GaussianBlur(eigen2cv(img), eigen2cv(blur));

cv::imshow(&amp;quot;sharpened&amp;quot;, eigen2cv(1.5 * img - 0.5 * blur));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;more&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;idea&#34;&gt;Idea&lt;/h2&gt;

&lt;p&gt;In fact, Eigen heavily use &lt;a href=&#34;#1&#34;&gt;C++ templates magic&lt;/a&gt; to create expression structures with delayed evaluation and &lt;a href=&#34;#2&#34;&gt;type traits&lt;/a&gt; to detect type of derived objects in compile time.
This approach gives compiler a lot of hints on actual data layout which helps to generate more efficient code.
The drawback of this - if you want to deep dive in Eigen internals be prepared to hardcore.&lt;/p&gt;

&lt;p&gt;I will use templates as well. We will have template class &lt;code&gt;Eigen2CV&lt;/code&gt; and several specializations of this class - for planar types, for blocks, for expression and so on&amp;hellip;
In addition we will specialize this class with mutable specification which will
let us to define &lt;u&gt;at compile time&lt;/u&gt; whether mapped object is allowed for writing or not. Awesome.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;
    typename Derived, 
    typename Base, 
    typename ConstPolicy, 
    typename StorageKind = typename Eigen::internal::traits&amp;lt;Derived&amp;gt;::StorageKind 
    &amp;gt;
class Eigen2CV;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To interact with OpenCV, we can declare implicit conversion operators for &lt;code&gt;cv::Mat&lt;/code&gt;, &lt;code&gt;cv::InputArray&lt;/code&gt; and &lt;code&gt;cv::OutputArray&lt;/code&gt;.
Some of the mapped objects can have read/write access while the rest  - read-only.
Therefore we will introduce the base class &lt;code&gt;Eigen2CVBase&lt;/code&gt; to provide a &amp;ldquo;read-only&amp;rdquo; access for all derived objects.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Eigen2CVBase
{
public:
    
    operator cv::Mat() const
    {
        return mBody;
    }
    
    operator cv::_InputArray() const
    {
        return cv::_InputArray(mBody);
    }
    
protected:
    
    template&amp;lt;typename Derived&amp;gt;
    void mapPlaneMemory(const Derived&amp;amp; src)
    {
        const bool isRowMajor = int(Derived::Flags) &amp;amp; Eigen::RowMajorBit;
        const int stride = src.outerStride() * sizeof(typename Derived::Scalar);
        
        if (isRowMajor)
            this-&amp;gt;mapPlaneMemoryRowMajor(src.data(),
                                         src.rows(),
                                         src.cols(),
                                         stride);
        else
            this-&amp;gt;mapPlaneMemoryColMajor(src.data(),
                                         src.rows(),
                                         src.cols(),
                                         stride);
    }

    template &amp;lt;typename Scalar&amp;gt;
    void mapPlaneMemoryRowMajor(const Scalar* planeData, int rows, int cols, int stride)
    {
        this-&amp;gt;mBody = cv::Mat(rows, 
                              cols, 
                              opencv_matrix&amp;lt;Scalar&amp;gt;::type, 
                              const_cast&amp;lt;Scalar*&amp;gt;(planeData), 
                              stride);
    }
    
    template &amp;lt;typename Scalar&amp;gt;
    void mapPlaneMemoryColMajor(const Scalar* planeData, int rows, int cols, int stride)
    {
        this-&amp;gt;mBody = cv::Mat(cols, 
                              rows, 
                              opencv_matrix&amp;lt;Scalar&amp;gt;::type, 
                              const_cast&amp;lt;Scalar*&amp;gt;(planeData), 
                              stride);
    }

    template &amp;lt;typename Derived, typename T&amp;gt;
    void assignMatrix(Eigen::DenseBase&amp;lt;Derived&amp;gt;&amp;amp; dst, const cv::Mat_&amp;lt;T&amp;gt;&amp;amp; src)
    {
        typedef typename Derived::Scalar Scalar;
        typedef Eigen::Matrix&amp;lt;T, 
                              Eigen::Dynamic, 
                              Eigen::Dynamic, 
                              Eigen::RowMajor&amp;gt; PlainMatrixType;
        
        dst = Eigen::Map&amp;lt;PlainMatrixType&amp;gt;((T*)src.data, 
                                          src.rows, 
                                          src.cols).
                                          template cast&amp;lt;Scalar&amp;gt;();
    }
    
    cv::Mat mBody;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For those Eigen types that allows read/write access, we will have additional conversion operator to cv::OutputArray. By default all derived types will have read-only access.&lt;/p&gt;

&lt;h2 id=&#34;mapping-eigen-plain-objects&#34;&gt;Mapping Eigen plain objects&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start from mapping continuous block of memory represented by &lt;code&gt;Eigen::Matrix&lt;/code&gt; of &lt;code&gt;Eigen::Array&lt;/code&gt;.
These two classes derives from &lt;code&gt;Eigen::PlainObjectBase&lt;/code&gt; class which provides methods to access internal storage
buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename Derived&amp;gt;
class Eigen2CV&amp;lt;
    Derived, 
    Eigen::PlainObjectBase&amp;lt;Derived&amp;gt;, 
    details::Const&amp;gt; : public Eigen2CVBase
{
public:
    
    typedef typename Derived::Scalar Scalar;
    typedef Eigen2CV&amp;lt;Derived, Eigen::PlainObjectBase&amp;lt;Derived&amp;gt;, details::Mutable&amp;gt; Self;
    
    Eigen2CV(const Eigen::PlainObjectBase&amp;lt;Derived&amp;gt;&amp;amp; src)
    : mMappedView(src)
    {
        this-&amp;gt;mapPlaneMemory(mMappedView);
    }
           
private:
    const Eigen::PlainObjectBase&amp;lt;Derived&amp;gt;&amp;amp; mMappedView;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is &lt;code&gt;Eigen2CV&lt;/code&gt; specialization for constant &lt;code&gt;Eigen::PlainObjectBase&lt;/code&gt; object. This specialization of &lt;code&gt;Eigen2CV&lt;/code&gt; can return constant reference to &lt;code&gt;cv::Mat&lt;/code&gt; and &lt;code&gt;cv::InputArray&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now we can write two overloads of &lt;code&gt;eigen2cv&lt;/code&gt; function for &lt;code&gt;Eigen::Matrix&lt;/code&gt; and &lt;code&gt;Eigen::Array&lt;/code&gt;. The goal of &lt;code&gt;eigen2cv&lt;/code&gt; is simple - take an argument and create &amp;lsquo;right&amp;rsquo; Eigen2CV&amp;lt;&amp;hellip;&amp;gt; mapper.
Here is how it looks like for planar data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename E&amp;gt;
Eigen2CV&amp;lt;E, Eigen::PlainObjectBase&amp;lt;E&amp;gt;, details::Mutable&amp;gt; 
eigen2cv(Eigen::PlainObjectBase&amp;lt;E&amp;gt;&amp;amp; src) 
{
    return Eigen2CV&amp;lt;E, 
                    Eigen::PlainObjectBase&amp;lt;E&amp;gt;, 
                    details::Mutable
                    &amp;gt;(src));
}

template&amp;lt;typename E&amp;gt;
Eigen2CV&amp;lt;E, Eigen::PlainObjectBase&amp;lt;E&amp;gt;, details::Const&amp;gt;
eigen2cv(const Eigen::PlainObjectBase&amp;lt;E&amp;gt;&amp;amp; src) 
{
    return Eigen2CV&amp;lt;E, 
                    Eigen::PlainObjectBase&amp;lt;E&amp;gt;, 
                    details::Const
                    &amp;gt;(src);
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I want to draw your attention to how elegant C++ allows us to distinct mutable and constant objects.
Compiler will choose right function depending on the context of &lt;code&gt;src&lt;/code&gt;.
In case of access right conflicts you will get compile-time error.&lt;/p&gt;

&lt;h2 id=&#34;assigning-opencv-matrix-to-eigen-object&#34;&gt;Assigning OpenCV matrix to Eigen object&lt;/h2&gt;

&lt;p&gt;What if someone write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;eigen2cv(a) = cv::imread(&amp;quot;lena.jpg&amp;quot;, cv::IMREAD_GRAYSCALE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, it&amp;rsquo;s legal and I see no problems with this code while we follow few restrictions:
1. &lt;code&gt;data&lt;/code&gt; has dynamic size or fixed one which match cv::Mat size.
2. Image is single channel - there is no way to map multi-channel images to Eigen now.&lt;/p&gt;

&lt;p&gt;Assignment operator is also quite simple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename T&amp;gt;
Self&amp;amp; operator=(const cv::Mat_&amp;lt;T&amp;gt;&amp;amp; src)
{
    assignMatrix&amp;lt;Derived, T&amp;gt;(mMappedView, src);
    return *this;
}

/**
 * @brief Assignment operator to copy OpenCV Mat data to mapped Eigen object.
 */
Self&amp;amp; operator= (const cv::Mat&amp;amp; m)
{
    switch (m.type())
    {
        case CV_8U:  return *this = (cv::Mat_&amp;lt;uint8_t&amp;gt;)m;
        case CV_16U: return *this = (cv::Mat_&amp;lt;uint16_t&amp;gt;)m;
        case CV_16S: return *this = (cv::Mat_&amp;lt;int16_t&amp;gt;)m;
        case CV_32S: return *this = (cv::Mat_&amp;lt;int32_t&amp;gt;)m;
        case CV_32F: return *this = (cv::Mat_&amp;lt;float&amp;gt;)m;
        case CV_64F: return *this = (cv::Mat_&amp;lt;double&amp;gt;)m;
        default:
            throw std::runtime_error(&amp;quot;Unsupported OpenCV matrix type&amp;quot;);
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mapping-eigen-expressions&#34;&gt;Mapping Eigen expressions&lt;/h2&gt;

&lt;p&gt;Dealing with expressions is not much harder.
Depending on the expression type, we must either evaluate it into dense storage (when it&amp;rsquo;s real expression like &lt;code&gt;AX + B&lt;/code&gt;, or &lt;code&gt;cast&amp;lt;float&amp;gt;()&lt;/code&gt;)
or use underlying storage with regards to expression operator (&lt;code&gt;block()&lt;/code&gt;, &lt;code&gt;transpose()&lt;/code&gt;, &lt;code&gt;array()&lt;/code&gt;, &lt;code&gt;matrix()&lt;/code&gt;).
We will get to mapping blocks in a next section.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s map expression that require evaluation first. For the sake of simplicity,
I will not implement write expressions, e.g expressions that require eval/update/write-back.
Eigen2CV will be able map Eigen expressions in read-only mode.
And here&amp;rsquo;s how:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename Derived&amp;gt;
class Eigen2CV&amp;lt;Derived, Eigen::EigenBase&amp;lt;Derived&amp;gt;, details::Const&amp;gt; : public Eigen2CVBase
{
public:
    typedef typename Derived::Scalar Scalar;
    typedef typename Eigen::internal::plain_matrix_type&amp;lt;Derived&amp;gt;::type StorageType;

    Eigen2CV(const Eigen::EigenBase&amp;lt;Derived&amp;gt;&amp;amp; src)
    {
        mStorage = src; // All magic happens here
        this-&amp;gt;mapPlaneMemory(mStorage);
    }

protected:

    void mapPlaneMemory(StorageType&amp;amp; src)
    {
        if ( ( StorageType::Options &amp;amp; Eigen::RowMajor) == Eigen::RowMajor)
            this-&amp;gt;mapPlaneMemoryRowMajor(src.data(), 
                                         src.rows(), 
                                         src.cols(), 
                                         src.outerStride() * sizeof(Scalar));
        else
            this-&amp;gt;mapPlaneMemoryColMajor(src.data(), 
                                         src.rows(), 
                                         src.cols(), 
                                         src.outerStride() * sizeof(Scalar));
    }

private:
    StorageType mStorage;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the first look, it is almost the same as specialization for planar data types. A few differences make this specialization very other one.
First, &lt;code&gt;Eigen::internal::plain_matrix_type&amp;lt;Derived&amp;gt;::type&lt;/code&gt; type trait helps us to infer type of dense storage for given expression.
Second, line &lt;code&gt;mStorage = src&lt;/code&gt; looks really simple right? But hold on, &lt;code&gt;src&lt;/code&gt; is an expression, and &lt;code&gt;mStorage&lt;/code&gt; is dense matrix.
Assignment operator makes our like much easier by performing evaluation step inside this assignment.&lt;/p&gt;

&lt;p&gt;And here is &lt;code&gt;eigen2cv&lt;/code&gt; overload for Eigen expressions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename E&amp;gt;
Eigen2CV&amp;lt;E, Eigen::EigenBase&amp;lt;E&amp;gt;, details::Const&amp;gt;
eigen2cv(const Eigen::EigenBase&amp;lt;E&amp;gt;&amp;amp; src) 
{
    return Eigen2CV&amp;lt;E, 
                    Eigen::EigenBase&amp;lt;E&amp;gt;, 
                    details::Const
                    &amp;gt;(src);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mapping-eigen-views&#34;&gt;Mapping Eigen views&lt;/h2&gt;

&lt;p&gt;User can create sub-view for the Eigen storage using &lt;code&gt;block()&lt;/code&gt;.
Eigen block create view that points to the same memory region, but has different size and stride.
Blocks can be read and written.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename Derived&amp;gt;
class Eigen2CV&amp;lt;Derived, 
               Eigen::Block&amp;lt;Derived&amp;gt;, 
               details::Mutable, 
               Eigen::Dense&amp;gt; : public Eigen2CVBase
{
public:
    typename Derived::Scalar Scalar;
    typedef Eigen2CV&amp;lt;Derived, Eigen::Block&amp;lt;Derived&amp;gt;, details::Mutable&amp;gt; Self;

    Eigen2CV(const Eigen::Block&amp;lt;Derived&amp;gt;&amp;amp; src)
        : mMappedView(src)
    {
        this-&amp;gt;mapPlaneMemory(mMappedView);
    }
    
    operator cv::_OutputArray()
    {
        return cv::_OutputArray(this-&amp;gt;mBody);
    }
    
    template &amp;lt;typename T&amp;gt;
    Self&amp;amp; operator=(const cv::Mat_&amp;lt;T&amp;gt;&amp;amp; src)
    {
        MatrixAssign&amp;lt;Derived, T&amp;gt;(mMappedView, src);
        return *this;
    }
    
    /**
     * @brief Assignment operator to copy OpenCV Mat data to mapped Eigen object.
     */
    Self&amp;amp; operator= (const cv::Mat&amp;amp; m) throw ()
    {
        switch (m.type())
        {
            case CV_8U:  return *this = (cv::Mat_&amp;lt;uint8_t&amp;gt;)m;
            case CV_16U: return *this = (cv::Mat_&amp;lt;uint16_t&amp;gt;)m;
            case CV_16S: return *this = (cv::Mat_&amp;lt;int16_t&amp;gt;)m;
            case CV_32S: return *this = (cv::Mat_&amp;lt;int32_t&amp;gt;)m;
            case CV_32F: return *this = (cv::Mat_&amp;lt;float&amp;gt;)m;
            case CV_64F: return *this = (cv::Mat_&amp;lt;double&amp;gt;)m;
            default:
                throw std::runtime_error(&amp;quot;Unsupported OpenCV matrix type&amp;quot;);
        };
    }
    
private:
    const Eigen::Block&amp;lt;Derived&amp;gt;&amp;amp; mMappedView;
};

template&amp;lt;typename E&amp;gt;
Eigen2CV&amp;lt;E, Eigen::Block&amp;lt;E&amp;gt;, details::Mutable&amp;gt;
eigen2cv(const Eigen::Block&amp;lt;E&amp;gt;&amp;amp; src)
{
    return Eigen2CV&amp;lt;E, 
                    Eigen::Block&amp;lt;E&amp;gt;, 
                    details::Mutable
                    &amp;gt;(src);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;eigen-memory-organization&#34;&gt;Eigen memory organization&lt;/h2&gt;

&lt;p&gt;Eigen can use column-major or row-major ordering of internal data storage.
By default it&amp;rsquo;s column-major, but OpenCV use row-major ordering.&lt;/p&gt;

&lt;p class=&#34;info info-warning&#34;&gt;
&lt;span class=&#34;label label-info&#34;&gt;Notice&lt;/span&gt;
This mapping implementation will NOT convert underlying Eigen memory to meet OpenCV convention. 
For column-major order of Eigen data type this will lead to transposed matrices in OpenCV. 
&lt;/p&gt;

&lt;h2 id=&#34;demonstration&#34;&gt;Demonstration&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Image8u_t a(512, 512); // Eigen::Matrix&amp;lt;uint8_t, Dynamic, Dynamic&amp;gt;

for (size_t i = 0; i &amp;lt; 512; i++)
{
    for (size_t j = 0; j &amp;lt; 512; j++)
    {
        a(i,j) = 255.0f * (sin(0.04f * i) * sin(0.04f * i) + 
                           cos(0.04f * j) * cos(0.04f * j));
    }
}

cv::GaussianBlur(eigen2cv(a.block(128, 128, 256, 256)),
                 eigen2cv(a.block(128, 128, 256, 256)), cv::Size(25,25), 0);
cv::imshow(&amp;quot;Blur image region&amp;quot;, eigen2cv(a));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;blur_roi.png&#34; alt=&#34;Blur image region&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;source-code&#34;&gt;Source code&lt;/h2&gt;

&lt;p&gt;Source code for this post can be found on GitHub: &lt;a href=&#34;https://gist.github.com/BloodAxe/c94d65d5977fb1d3e53f&#34;&gt;Eigen2CV.h&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;License: &lt;a href=&#34;https://tldrlegal.com/license/bsd-3-clause-license-(revised)#summary&#34;&gt;BSD-3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a name=&#34;#1&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/gp/product/0201704315/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201704315&amp;linkCode=as2&amp;tag=compvisitalk-20&amp;linkId=2ZA2JDQNEDOQJZFL&#34;&gt;Modern C++ Design: Generic Programming and Design Patterns Applied&lt;/a&gt;&lt;img src=&#34;http://ir-na.amazon-adsystem.com/e/ir?t=compvisitalk-20&amp;l=as2&amp;o=1&amp;a=0201704315&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a name=&#34;#2&#34; /&gt;
2. &lt;a href=&#34;http://www.drdobbs.com/cpp/c-type-traits/184404270&#34;&gt;http://www.drdobbs.com/cpp/c-type-traits/184404270&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>